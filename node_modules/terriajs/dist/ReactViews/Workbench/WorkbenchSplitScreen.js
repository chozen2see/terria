var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// import React, { useState } from "react";
import React from "react";
import PropTypes from "prop-types";
import { runInAction } from "mobx";
import { observer } from "mobx-react";
// import styled from "styled-components";
import classNames from "classnames";
import Icon from "../../Styled/Icon";
import Box from "../../Styled/Box";
import Spacing from "../../Styled/Spacing";
import { RawButton } from "../../Styled/Button";
import ImagerySplitDirection from "terriajs-cesium/Source/Scene/ImagerySplitDirection";
import ViewerMode from "../../Models/ViewerMode";
import DropdownStyles from "../Map/Panels/panel.scss";
import Styles from "../Map/Panels/setting-panel.scss";
// mangled from SettingPanel.jsx
let WorkbenchSplitScreen = class WorkbenchSplitScreen extends React.Component {
    render() {
        const props = this.props;
        const terria = props.terria;
        const showTerrainOnSide = (side, event) => {
            event && event.stopPropagation();
            runInAction(() => {
                switch (side) {
                    case "Left":
                        terria.terrainSplitDirection = ImagerySplitDirection.LEFT;
                        terria.showSplitter = true;
                        break;
                    case "Right":
                        terria.terrainSplitDirection = ImagerySplitDirection.RIGHT;
                        terria.showSplitter = true;
                        break;
                    case "Both":
                        terria.terrainSplitDirection = ImagerySplitDirection.NONE;
                        break;
                }
                terria.currentViewer.notifyRepaintRequired();
            });
        };
        const toggleDepthTestAgainstTerrainEnabled = event => {
            event && event.stopPropagation();
            runInAction(() => {
                this.props.terria.depthTestAgainstTerrainEnabled = !this.props.terria
                    .depthTestAgainstTerrainEnabled;
            });
            terria.currentViewer.notifyRepaintRequired();
        };
        const isCesiumWithTerrain = terria.mainViewer.viewerMode === ViewerMode.Cesium &&
            terria.mainViewer.viewerOptions.useTerrain &&
            terria.currentViewer &&
            terria.currentViewer.scene &&
            terria.currentViewer.scene.globe;
        const supportsDepthTestAgainstTerrain = isCesiumWithTerrain;
        const supportsSide = isCesiumWithTerrain;
        const sides = ["Left", "Both", "Right"];
        let currentSide = "Both";
        if (supportsSide) {
            switch (terria.terrainSplitDirection) {
                case ImagerySplitDirection.LEFT:
                    currentSide = "Left";
                    break;
                case ImagerySplitDirection.RIGHT:
                    currentSide = "Right";
                    break;
            }
        }
        const depthTestAgainstTerrainEnabled = supportsDepthTestAgainstTerrain && terria.depthTestAgainstTerrainEnabled;
        // const depthTestAgainstTerrainFlag =
        //   terria.currentViewer &&
        //   terria.currentViewer.scene &&
        //   terria.currentViewer.scene.globe &&
        //   terria.currentViewer.scene.globe.depthTestAgainstTerrain;
        const depthTestAgainstTerrainLabel = `Press to start ${depthTestAgainstTerrainEnabled ? "showing" : "hiding"} features that are underneath the terrain surface`;
        // const { t } = useTranslation();
        return (React.createElement(If, { condition: supportsSide },
            React.createElement(Box, { fullWidth: true, column: true, css: `
            background: ${p => p.theme.darkWithOverlay};
            color: ${p => p.theme.textLight};
            svg {
              fill: ${p => p.theme.textLight};
              width: 14px;
              height: 14px;
            }
            margin: 5px 0;
            border: 1px solid rgba(255, 255, 255, 0.15);
          ` },
                React.createElement(Box, { fullWidth: true, centered: true, justifySpaceBetween: true, css: `
              background: ${p => p.theme.colorSecondary};
              padding: 0 10px;
              font-weight: bold;
              font-size: 14px;
              color: ${p => p.theme.textLight};
              letter-spacing: 0;
              line-height: 34px;
            ` },
                    React.createElement(Box, null, "SPLIT SCREEN MODE"),
                    React.createElement(RawButton, { onClick: () => {
                            runInAction(() => (terria.showSplitter = !terria.showSplitter));
                        } },
                        React.createElement(Icon, { glyph: Icon.GLYPHS.close }))),
                React.createElement(Box, { column: true, css: `
              background: ${p => p.theme.darkWithOverlay};
              padding: 5px 10px;
            ` },
                    React.createElement(Spacing, { bottom: 1 }),
                    React.createElement(Box, null,
                        React.createElement("label", { className: DropdownStyles.heading }, "Terrain position"),
                        React.createElement(Spacing, { bottom: 1 })),
                    React.createElement(Box, null,
                        React.createElement("ul", { className: Styles.viewerSelector, css: `
                  display: flex;
                  width: 100%;
                  margin: 0;
                  li {
                    padding: 0;
                  }
                ` },
                            React.createElement(For, { each: "side", of: sides },
                                React.createElement("li", { key: side, css: `
                      flex: 1;
                    ` },
                                    React.createElement("button", { onClick: () => showTerrainOnSide(side), className: classNames(Styles.btnViewer, {
                                            [Styles.isActive]: side === currentSide,
                                            [Styles.isActiveSplitter]: side === currentSide
                                        }), css: `
                        &:not(select) {
                          border: none !important;
                          height: 30px;
                          font-size: 0.85rem;
                          font-weight: 400;
                          line-height: 20px;

                          &:hover,
                          &:focus {
                            background-color: ${p => p.theme.colorSecondary};
                          }
                        }
                      ` }, side))))),
                    React.createElement(If, { condition: supportsDepthTestAgainstTerrain },
                        React.createElement(React.Fragment, null,
                            React.createElement(Spacing, { bottom: 2 }),
                            React.createElement(Box, { className: Styles.nativeResolutionWrapper },
                                React.createElement("button", { id: "depthTestAgainstTerrain", type: "button", onClick: () => toggleDepthTestAgainstTerrainEnabled(), title: depthTestAgainstTerrainLabel, className: Styles.btnNativeResolution }, depthTestAgainstTerrainEnabled ? (React.createElement(Icon, { glyph: Icon.GLYPHS.checkboxOn })) : (React.createElement(Icon, { glyph: Icon.GLYPHS.checkboxOff }))),
                                React.createElement("label", { title: depthTestAgainstTerrainLabel, htmlFor: "depthTestAgainstTerrain", className: classNames(DropdownStyles.subHeading, Styles.nativeResolutionHeader) }, "Terrain hides underground features")))),
                    React.createElement(Spacing, { bottom: 1 })))));
    }
};
WorkbenchSplitScreen = __decorate([
    observer
], WorkbenchSplitScreen);
WorkbenchSplitScreen.propTypes = {
    terria: PropTypes.object
};
export default WorkbenchSplitScreen;
//# sourceMappingURL=WorkbenchSplitScreen.js.map