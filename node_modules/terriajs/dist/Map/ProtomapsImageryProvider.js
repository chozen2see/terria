var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import Point from "@mapbox/point-geometry";
import bbox from "@turf/bbox";
import booleanIntersects from "@turf/boolean-intersects";
import circle from "@turf/circle";
import { feature } from "@turf/helpers";
import i18next from "i18next";
import { observable, runInAction } from "mobx";
import Cartographic from "terriajs-cesium/Source/Core/Cartographic";
import Credit from "terriajs-cesium/Source/Core/Credit";
import defaultValue from "terriajs-cesium/Source/Core/defaultValue";
import DeveloperError from "terriajs-cesium/Source/Core/DeveloperError";
import CesiumEvent from "terriajs-cesium/Source/Core/Event";
import CesiumMath from "terriajs-cesium/Source/Core/Math";
import Rectangle from "terriajs-cesium/Source/Core/Rectangle";
import WebMercatorTilingScheme from "terriajs-cesium/Source/Core/WebMercatorTilingScheme";
import ImageryLayerFeatureInfo from "terriajs-cesium/Source/Scene/ImageryLayerFeatureInfo";
import when from "terriajs-cesium/Source/ThirdParty/when";
import { Labelers, painter, PmtilesSource, TileCache, View, ZxySource } from "terriajs-protomaps";
import filterOutUndefined from "../Core/filterOutUndefined";
import isDefined from "../Core/isDefined";
const geojsonvt = require("geojson-vt").default;
/** Buffer (in pixels) used when rendering (and generating - through geojson-vt) vector tiles */
const BUF = 64;
/** Tile size in pixels (for canvas and geojson-vt) */
const tilesize = 256;
/** Extent (of coordinates) of tiles generated by geojson-vt */
const geojsonvtExtent = 4096;
/** Layer name to use with geojson-vt
 *  This must be used in PaintRules/LabelRules (eg `dataLayer: "layer"`)
 */
export const GEOJSON_SOURCE_LAYER_NAME = "layer";
export class GeojsonSource {
    constructor(url) {
        this.data = url;
        if (!(typeof url === "string")) {
            this.geojsonObject = url;
        }
    }
    /** Fetch geoJSON data (if required) and tile with geojson-vt */
    async fetchData() {
        let result;
        if (typeof this.data === "string") {
            result = await (await fetch(this.data)).json();
        }
        else {
            result = this.data;
        }
        runInAction(() => (this.geojsonObject = result));
        return geojsonvt(this.geojsonObject, {
            buffer: (BUF / tilesize) * geojsonvtExtent,
            extent: geojsonvtExtent,
            maxZoom: 24
        });
    }
    async get(c, tileSize) {
        if (!this.tileIndex) {
            this.tileIndex = this.fetchData();
        }
        // request a particular tile
        const tile = (await this.tileIndex).getTile(c.z, c.x, c.y);
        let result = new Map();
        const scale = tilesize / geojsonvtExtent;
        if (tile && tile.features && tile.features.length > 0) {
            result.set(GEOJSON_SOURCE_LAYER_NAME, 
            // We have to transform feature objects from GeojsonVtTile to ProtomapsFeature
            tile.features.map(f => {
                let transformedGeom = [];
                let numVertices = 0;
                // Calculate bbox
                let bbox = {
                    minX: Infinity,
                    minY: Infinity,
                    maxX: -Infinity,
                    maxY: -Infinity
                };
                // Multi geometry (eg polygon, multi-line string)
                if (Array.isArray(f.geometry[0][0])) {
                    const geom = f.geometry;
                    transformedGeom = geom.map(g1 => g1.map(g2 => {
                        g2 = [g2[0] * scale, g2[1] * scale];
                        if (bbox.minX > g2[0]) {
                            bbox.minX = g2[0];
                        }
                        if (bbox.maxX < g2[0]) {
                            bbox.maxX = g2[0];
                        }
                        if (bbox.minY > g2[1]) {
                            bbox.minY = g2[1];
                        }
                        if (bbox.maxY < g2[1]) {
                            bbox.maxY = g2[1];
                        }
                        return new Point(g2[0], g2[1]);
                    }));
                    numVertices = transformedGeom.reduce((count, current) => count + current.length, 0);
                }
                // Flat geometry (line string, point)
                else {
                    const geom = f.geometry;
                    transformedGeom = [
                        geom.map(g1 => {
                            g1 = [g1[0] * scale, g1[1] * scale];
                            if (bbox.minX > g1[0]) {
                                bbox.minX = g1[0];
                            }
                            if (bbox.maxX < g1[0]) {
                                bbox.maxX = g1[0];
                            }
                            if (bbox.minY > g1[1]) {
                                bbox.minY = g1[1];
                            }
                            if (bbox.maxY < g1[1]) {
                                bbox.maxY = g1[1];
                            }
                            return new Point(g1[0], g1[1]);
                        })
                    ];
                    numVertices = transformedGeom.length;
                }
                const feature = {
                    props: f.tags,
                    bbox,
                    geomType: f.type,
                    geom: transformedGeom,
                    numVertices
                };
                return feature;
            }));
        }
        return result;
    }
}
__decorate([
    observable.ref
], GeojsonSource.prototype, "geojsonObject", void 0);
export default class ProtomapsImageryProvider {
    constructor(options) {
        this._errorEvent = new CesiumEvent();
        this._ready = true;
        this.terria = options.terria;
        this._tilingScheme = new WebMercatorTilingScheme();
        this._tileWidth = tilesize;
        this._tileHeight = tilesize;
        this._minimumLevel = defaultValue(options.minimumZoom, 0);
        this._maximumLevel = defaultValue(options.maximumZoom, 24);
        this._rectangle = isDefined(options.rectangle)
            ? Rectangle.intersection(options.rectangle, this._tilingScheme.rectangle) || this._tilingScheme.rectangle
            : this._tilingScheme.rectangle;
        // Check the number of tiles at the minimum level.  If it's more than four,
        // throw an exception, because starting at the higher minimum
        // level will cause too many tiles to be downloaded and rendered.
        const swTile = this._tilingScheme.positionToTileXY(Rectangle.southwest(this._rectangle), this._minimumLevel);
        const neTile = this._tilingScheme.positionToTileXY(Rectangle.northeast(this._rectangle), this._minimumLevel);
        const tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
        if (tileCount > 4) {
            throw new DeveloperError(i18next.t("map.mapboxVectorTileImageryProvider.moreThanFourTiles", {
                tileCount: tileCount
            }));
        }
        this._errorEvent = new CesiumEvent();
        this._ready = true;
        this._credit = options.credit;
        // Protomaps
        this.paintRules = options.paintRules;
        this.labelRules = options.labelRules;
        // Generate protomaps source based on options.data
        // - URL of pmtiles, geojson or pbf files
        if (typeof options.data === "string") {
            if (options.data.endsWith(".pmtiles")) {
                this.source = new PmtilesSource(options.data, false);
                let cache = new TileCache(this.source, 1024);
                this.view = new View(cache, 14, 2);
            }
            else if (options.data.endsWith(".json") ||
                options.data.endsWith(".geojson")) {
                this.source = new GeojsonSource(options.data);
            }
            else {
                this.source = new ZxySource(options.data, false);
                let cache = new TileCache(this.source, 1024);
                this.view = new View(cache, 14, 2);
            }
            // - GeoJSON object
        }
        else {
            this.source = new GeojsonSource(options.data);
        }
        this.labelers = new Labelers(document.createElement("canvas").getContext("2d"), this.labelRules, () => undefined);
    }
    get tileWidth() {
        return this._tileWidth;
    }
    get tileHeight() {
        return this._tileHeight;
    }
    get maximumLevel() {
        return this._maximumLevel;
    }
    get minimumLevel() {
        return this._minimumLevel;
    }
    get tilingScheme() {
        return this._tilingScheme;
    }
    get rectangle() {
        return this._rectangle;
    }
    get errorEvent() {
        return this._errorEvent;
    }
    get ready() {
        return this._ready;
    }
    get defaultNightAlpha() {
        return undefined;
    }
    get defaultDayAlpha() {
        return undefined;
    }
    get hasAlphaChannel() {
        return true;
    }
    get credit() {
        let credit = this._credit;
        if (credit === undefined) {
            return undefined;
        }
        else if (typeof credit === "string") {
            credit = new Credit(credit);
        }
        return credit;
    }
    get defaultAlpha() {
        return undefined;
    }
    get defaultBrightness() {
        return undefined;
    }
    get defaultContrast() {
        return undefined;
    }
    get defaultGamma() {
        return undefined;
    }
    get defaultHue() {
        return undefined;
    }
    get defaultSaturation() {
        return undefined;
    }
    get defaultMagnificationFilter() {
        return undefined;
    }
    get defaultMinificationFilter() {
        return undefined;
    }
    get proxy() {
        return undefined;
    }
    get readyPromise() {
        return when(true);
    }
    get tileDiscardPolicy() {
        return undefined;
    }
    getTileCredits(x, y, level) {
        return [];
    }
    async requestImage(x, y, level) {
        const canvas = document.createElement("canvas");
        canvas.width = this.tileWidth;
        canvas.height = this.tileHeight;
        return await this.requestImageForCanvas(x, y, level, canvas);
    }
    async requestImageForCanvas(x, y, level, canvas) {
        try {
            await this.renderTile({ x, y, z: level }, canvas);
        }
        catch (e) {
            console.log(e);
        }
        return canvas;
    }
    async renderTile(coords, canvas) {
        // Adapted from https://github.com/protomaps/protomaps.js/blob/master/src/frontends/leaflet.ts
        let tile = undefined;
        // Get PreparedTile from source or view
        // Here we need a little bit of extra logic for the GeojsonSource
        if (this.source instanceof GeojsonSource) {
            const data = await this.source.get(coords, this.tileHeight);
            tile = {
                data: data,
                z: coords.z,
                data_tile: coords,
                scale: 1,
                origin: new Point(coords.x * 256, coords.y * 256),
                dim: this.tileWidth
            };
        }
        else if (this.view) {
            tile = await this.view.getDisplayTile(coords);
        }
        if (!tile)
            return;
        this.labelers.add(tile);
        let labelData = this.labelers.getIndex(tile.z);
        const bbox = {
            minX: 256 * coords.x - BUF,
            minY: 256 * coords.y - BUF,
            maxX: 256 * (coords.x + 1) + BUF,
            maxY: 256 * (coords.y + 1) + BUF
        };
        const origin = new Point(256 * coords.x, 256 * coords.y);
        const ctx = canvas.getContext("2d");
        if (!ctx)
            return;
        ctx.setTransform(this.tileWidth / 256, 0, 0, this.tileHeight / 256, 0, 0);
        ctx.clearRect(0, 0, 256, 256);
        if (labelData)
            painter(ctx, [tile], labelData, this.paintRules, bbox, origin, false, "");
    }
    async pickFeatures(x, y, level, longitude, latitude) {
        // If view is set - this means we are using actual vector tiles (that is not GeoJson object)
        // So we use this.view.queryFeatures
        if (this.view) {
            // Get list of vector tile layers which are rendered
            const renderedLayers = [...this.paintRules, ...this.labelRules].map(r => r.dataLayer);
            return filterOutUndefined(this.view
                .queryFeatures(CesiumMath.toDegrees(longitude), CesiumMath.toDegrees(latitude), level)
                .map(f => {
                // Only create FeatureInfo for visible features with properties
                if (!f.feature.props ||
                    f.feature.props === {} ||
                    !renderedLayers.includes(f.layerName))
                    return;
                const featureInfo = new ImageryLayerFeatureInfo();
                featureInfo.properties = f.feature.props;
                featureInfo.position = new Cartographic(longitude, latitude);
                featureInfo.configureDescriptionFromProperties(f.feature.props);
                featureInfo.configureNameFromProperties(f.feature.props);
                return featureInfo;
            }));
            // No view is set and we have geoJSON object
            // So we pick feautures manually
        }
        else if (this.source instanceof GeojsonSource &&
            this.source.geojsonObject) {
            // Create circle with 10 pixel radius to pick features
            const buffer = circle([CesiumMath.toDegrees(longitude), CesiumMath.toDegrees(latitude)], 10 * this.terria.mainViewer.scale, {
                steps: 10,
                units: "meters"
            });
            const bufferBbox = bbox(buffer);
            // Get array of all features
            let features = [];
            if (this.source.geojsonObject.type === "FeatureCollection") {
                features = this.source.geojsonObject.features;
            }
            else if (this.source.geojsonObject.type === "Feature") {
                features = [this.source.geojsonObject];
            }
            else {
                features = [feature(this.source.geojsonObject)];
            }
            const pickedFeatures = [];
            for (let index = 0; index < features.length; index++) {
                const feature = features[index];
                if (!feature.bbox) {
                    feature.bbox = bbox(feature);
                }
                // Filter by bounding box and then intersection with buffer
                if (Math.max(feature.bbox[0], bufferBbox[0]) <=
                    Math.min(feature.bbox[2], bufferBbox[2]) &&
                    Math.max(feature.bbox[1], bufferBbox[1]) <=
                        Math.min(feature.bbox[3], bufferBbox[3]) &&
                    booleanIntersects(feature, buffer)) {
                    pickedFeatures.push(feature);
                }
            }
            // Convert pickedFeatures to ImageryLayerFeatureInfos
            return pickedFeatures.map(f => {
                const featureInfo = new ImageryLayerFeatureInfo();
                featureInfo.data = f;
                featureInfo.properties = f.properties;
                if (f.geometry.type === "Point") {
                    featureInfo.position = Cartographic.fromDegrees(f.geometry.coordinates[0], f.geometry.coordinates[1]);
                }
                featureInfo.configureDescriptionFromProperties(f.properties);
                featureInfo.configureNameFromProperties(f.properties);
                return featureInfo;
            });
        }
        return [];
    }
}
//# sourceMappingURL=ProtomapsImageryProvider.js.map