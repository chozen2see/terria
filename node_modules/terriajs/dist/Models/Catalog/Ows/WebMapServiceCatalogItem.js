var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// const mobx = require('mobx');
// const mobxUtils = require('mobx-utils');
// Problems in current architecture:
// 1. After loading, can't tell what user actually set versus what came from e.g. GetCapabilities.
//  Solution: layering
// 2. CkanCatalogItem producing a WebMapServiceCatalogItem on load
// 3. Observable spaghetti
//  Solution: think in terms of pipelines with computed observables, document patterns.
// 4. All code for all catalog item types needs to be loaded before we can do anything.
import i18next from "i18next";
import { computed, runInAction } from "mobx";
import combine from "terriajs-cesium/Source/Core/combine";
import GeographicTilingScheme from "terriajs-cesium/Source/Core/GeographicTilingScheme";
import JulianDate from "terriajs-cesium/Source/Core/JulianDate";
import WebMercatorTilingScheme from "terriajs-cesium/Source/Core/WebMercatorTilingScheme";
import WebMapServiceImageryProvider from "terriajs-cesium/Source/Scene/WebMapServiceImageryProvider";
import URI from "urijs";
import containsAny from "../../../Core/containsAny";
import createDiscreteTimesFromIsoSegments from "../../../Core/createDiscreteTimes";
import createTransformerAllowUndefined from "../../../Core/createTransformerAllowUndefined";
import filterOutUndefined from "../../../Core/filterOutUndefined";
import isDefined from "../../../Core/isDefined";
import isReadOnlyArray from "../../../Core/isReadOnlyArray";
import TerriaError from "../../../Core/TerriaError";
import CatalogMemberMixin from "../../../ModelMixins/CatalogMemberMixin";
import ChartableMixin from "../../../ModelMixins/ChartableMixin";
import DiffableMixin from "../../../ModelMixins/DiffableMixin";
import ExportableMixin from "../../../ModelMixins/ExportableMixin";
import GetCapabilitiesMixin from "../../../ModelMixins/GetCapabilitiesMixin";
import TileErrorHandlerMixin from "../../../ModelMixins/TileErrorHandlerMixin";
import TimeFilterMixin from "../../../ModelMixins/TimeFilterMixin";
import UrlMixin from "../../../ModelMixins/UrlMixin";
import { terriaTheme } from "../../../ReactViews/StandardUserInterface/StandardTheme";
import { InfoSectionTraits, MetadataUrlTraits } from "../../../Traits/TraitsClasses/CatalogMemberTraits";
import LegendTraits from "../../../Traits/TraitsClasses/LegendTraits";
import WebMapServiceCatalogItemTraits, { SUPPORTED_CRS_3857, SUPPORTED_CRS_4326 } from "../../../Traits/TraitsClasses/WebMapServiceCatalogItemTraits";
import { callWebCoverageService } from "./callWebCoverageService";
import CommonStrata from "../../Definition/CommonStrata";
import CreateModel from "../../Definition/CreateModel";
import createStratumInstance from "../../Definition/createStratumInstance";
import LoadableStratum from "../../Definition/LoadableStratum";
import proxyCatalogItemUrl from "../proxyCatalogItemUrl";
import WebMapServiceCapabilities, { getRectangleFromLayer } from "./WebMapServiceCapabilities";
import MinMaxLevelMixin from "../../../ModelMixins/MinMaxLevelMixin";
const dateFormat = require("dateformat");
class GetCapabilitiesStratum extends LoadableStratum(WebMapServiceCatalogItemTraits) {
    constructor(catalogItem, capabilities) {
        super();
        this.catalogItem = catalogItem;
        this.capabilities = capabilities;
    }
    static async load(catalogItem, capabilities) {
        if (!isDefined(catalogItem.getCapabilitiesUrl)) {
            throw new TerriaError({
                title: i18next.t("models.webMapServiceCatalogItem.missingUrlTitle"),
                message: i18next.t("models.webMapServiceCatalogItem.missingUrlMessage")
            });
        }
        if (!isDefined(capabilities))
            capabilities = await WebMapServiceCapabilities.fromUrl(proxyCatalogItemUrl(catalogItem, catalogItem.getCapabilitiesUrl, catalogItem.getCapabilitiesCacheDuration));
        return new GetCapabilitiesStratum(catalogItem, capabilities);
    }
    duplicateLoadableStratum(model) {
        return new GetCapabilitiesStratum(model, this.capabilities);
    }
    get metadataUrls() {
        const metadataUrls = [];
        Array.from(this.capabilitiesLayers.values()).forEach(layer => {
            if (!(layer === null || layer === void 0 ? void 0 : layer.MetadataURL))
                return;
            Array.isArray(layer === null || layer === void 0 ? void 0 : layer.MetadataURL)
                ? metadataUrls.push(...layer === null || layer === void 0 ? void 0 : layer.MetadataURL)
                : metadataUrls.push(layer === null || layer === void 0 ? void 0 : layer.MetadataURL);
        });
        return metadataUrls
            .filter(m => { var _a; return (_a = m.OnlineResource) === null || _a === void 0 ? void 0 : _a["xlink:href"]; })
            .map(m => createStratumInstance(MetadataUrlTraits, {
            url: m.OnlineResource["xlink:href"]
        }));
    }
    get layers() {
        let layers;
        if (this.catalogItem.uri !== undefined) {
            // Try to extract a layer from the URL
            const query = this.catalogItem.uri.query(true);
            layers = query.layers;
        }
        if (layers === undefined) {
            // Use all the top-level, named layers
            layers = filterOutUndefined(this.capabilities.topLevelNamedLayers.map(layer => layer.Name)).join(",");
        }
        return layers;
    }
    /**
   * **How we determine WMS legends (in order)**
    1. Defined manually in catalog JSON
    2. If `style` is undefined, and server doesn't support `GetLegendGraphic`, we must select first style as default - as there is no way to know what the default style is, and to request a legend for it
    3. If `style` is is set and it has a `legendUrl` -> use it!
    4. If server supports `GetLegendGraphic`, we can request a legend (with or without `style` parameter)
   */
    get legends() {
        var _a, _b, _c;
        const availableStyles = this.catalogItem.availableStyles || [];
        const layers = this.catalogItem.layersArray;
        const styles = this.catalogItem.stylesArray;
        const result = [];
        for (let i = 0; i < layers.length; ++i) {
            const layer = layers[i];
            const style = i < styles.length ? styles[i] : undefined;
            let legendUri;
            let legendUrlMimeType;
            let legendScaling;
            const layerAvailableStyles = (_a = availableStyles.find(candidate => candidate.layerName === layer)) === null || _a === void 0 ? void 0 : _a.styles;
            let layerStyle;
            if (isDefined(style)) {
                // Attempt to find layer style based on AvailableStyleTraits
                layerStyle = layerAvailableStyles === null || layerAvailableStyles === void 0 ? void 0 : layerAvailableStyles.find(candidate => candidate.name === style);
            }
            // If no style is selected and this WMS doesn't support GetLegendGraphics - we must use the first style if none is explicitly specified.
            // (If WMS supports GetLegendGraphics we can use it and omit style parameter to get the "default" style's legend)
            if (!isDefined(layerStyle) && !this.catalogItem.supportsGetLegendGraphic)
                layerStyle = layerAvailableStyles === null || layerAvailableStyles === void 0 ? void 0 : layerAvailableStyles[0];
            // If legend found - proxy URL and set mimetype
            if ((_b = layerStyle === null || layerStyle === void 0 ? void 0 : layerStyle.legend) === null || _b === void 0 ? void 0 : _b.url) {
                legendUri = URI(proxyCatalogItemUrl(this.catalogItem, layerStyle.legend.url));
                legendUrlMimeType = layerStyle.legend.urlMimeType;
            }
            // If no legends found and WMS supports GetLegendGraphics - make one up!
            if (!isDefined(legendUri) &&
                isDefined(this.catalogItem.url) &&
                this.catalogItem.supportsGetLegendGraphic) {
                legendUri = URI(proxyCatalogItemUrl(this.catalogItem, this.catalogItem.url.split("?")[0]));
                legendUri
                    .setQuery("service", "WMS")
                    .setQuery("version", "1.3.0")
                    .setQuery("request", "GetLegendGraphic")
                    .setQuery("format", "image/png")
                    .setQuery("layer", layer);
                // From OGC â€” about style property for GetLegendGraphic request:
                // If not present, the default style is selected. The style may be any valid style available for a layer, including non-SLD internally-defined styles.
                if (style) {
                    legendUri.setQuery("style", style);
                }
                legendUrlMimeType = "image/png";
            }
            if (isDefined(legendUri)) {
                // Add geoserver related LEGEND_OPTIONS to match terria styling (if supported)
                if (this.catalogItem.isGeoServer &&
                    legendUri.hasQuery("request", "GetLegendGraphic")) {
                    let legendOptions = "fontName:Courier;fontStyle:bold;fontSize:12;forceLabels:on;fontAntiAliasing:true;labelMargin:5";
                    // Geoserver fontColor must be a hex value - use `textLight` theme colour
                    let fontColor = (_c = terriaTheme.textLight.split("#")) === null || _c === void 0 ? void 0 : _c[1];
                    if (isDefined(fontColor)) {
                        // If fontColor is a 3-character hex -> turn into 6
                        if (fontColor.length === 3) {
                            fontColor = `${fontColor[0]}${fontColor[0]}${fontColor[1]}${fontColor[1]}${fontColor[2]}${fontColor[2]}`;
                        }
                        legendOptions += `;fontColor:0x${fontColor}`;
                    }
                    legendOptions += ";dpi:182"; // enable if we can scale the image back down by 50%.
                    legendScaling = 0.5;
                    legendUri.setQuery("LEGEND_OPTIONS", legendOptions);
                    legendUri.setQuery("transparent", "true");
                }
                // Add colour scale range params if supported
                if (this.catalogItem.supportsColorScaleRange &&
                    this.catalogItem.colorScaleRange) {
                    legendUri.setQuery("colorscalerange", this.catalogItem.colorScaleRange);
                }
                result.push(createStratumInstance(LegendTraits, {
                    url: legendUri.toString(),
                    urlMimeType: legendUrlMimeType,
                    imageScaling: legendScaling
                }));
            }
        }
        return result;
    }
    get capabilitiesLayers() {
        const lookup = name => [
            name,
            this.capabilities && this.capabilities.findLayer(name)
        ];
        return new Map(this.catalogItem.layersArray.map(lookup));
    }
    get crs() {
        var _a;
        // Get set of supported CRS from layer hierarchy
        const layerCrs = new Set();
        this.capabilitiesLayers.forEach(layer => {
            if (layer) {
                const srs = this.capabilities.getInheritedValues(layer, "SRS");
                const crs = this.capabilities.getInheritedValues(layer, "CRS");
                [
                    ...(Array.isArray(srs) ? srs : [srs]),
                    ...(Array.isArray(crs) ? crs : [crs])
                ].forEach(c => layerCrs.add(c));
            }
        });
        // Note order is important here, the first one found will be used
        const supportedCrs = [...SUPPORTED_CRS_3857, ...SUPPORTED_CRS_4326];
        // If nothing is supported, ask for EPSG:3857, and hope for the best.
        return (_a = supportedCrs.find(crs => layerCrs.has(crs))) !== null && _a !== void 0 ? _a : "EPSG:3857";
    }
    get availableDimensions() {
        const result = [];
        if (!this.capabilities) {
            return result;
        }
        const capabilitiesLayers = this.capabilitiesLayers;
        for (const layerTuple of capabilitiesLayers) {
            const layerName = layerTuple[0];
            const layer = layerTuple[1];
            const dimensions = layer
                ? this.capabilities.getInheritedValues(layer, "Dimension")
                : [];
            result.push({
                layerName: layerName,
                dimensions: dimensions
                    .filter(dim => dim.name !== "time")
                    .map(dim => {
                    var _a;
                    return {
                        name: dim.name,
                        units: dim.units,
                        unitSymbol: dim.unitSymbol,
                        default: dim.default,
                        multipleValues: dim.multipleValues,
                        current: dim.current,
                        nearestValue: dim.nearestValue,
                        values: (_a = dim.text) === null || _a === void 0 ? void 0 : _a.split(",")
                    };
                })
            });
        }
        return result;
    }
    get availableStyles() {
        const result = [];
        if (!this.capabilities) {
            return result;
        }
        const capabilitiesLayers = this.capabilitiesLayers;
        for (const layerTuple of capabilitiesLayers) {
            const layerName = layerTuple[0];
            const layer = layerTuple[1];
            const styles = layer
                ? this.capabilities.getInheritedValues(layer, "Style")
                : [];
            result.push({
                layerName: layerName,
                styles: styles.map(style => {
                    var wmsLegendUrl = isReadOnlyArray(style.LegendURL)
                        ? style.LegendURL[0]
                        : style.LegendURL;
                    var legendUri, legendMimeType;
                    if (wmsLegendUrl &&
                        wmsLegendUrl.OnlineResource &&
                        wmsLegendUrl.OnlineResource["xlink:href"]) {
                        legendUri = new URI(decodeURIComponent(wmsLegendUrl.OnlineResource["xlink:href"]));
                        legendMimeType = wmsLegendUrl.Format;
                    }
                    const legend = !legendUri
                        ? undefined
                        : createStratumInstance(LegendTraits, {
                            url: legendUri.toString(),
                            urlMimeType: legendMimeType,
                            title: (capabilitiesLayers.size > 1 && (layer === null || layer === void 0 ? void 0 : layer.Title)) || undefined // Add layer Title as legend title if showing multiple layers
                        });
                    return {
                        name: style.Name,
                        title: style.Title,
                        abstract: style.Abstract,
                        legend: legend
                    };
                })
            });
        }
        return result;
    }
    get info() {
        const result = [];
        let firstDataDescription;
        result.push(createStratumInstance(InfoSectionTraits, {
            name: i18next.t("models.webMapServiceCatalogItem.serviceDescription"),
            contentAsObject: this.capabilities.Service,
            // Hide big ugly table by default
            show: false
        }));
        const onlyHasSingleLayer = this.catalogItem.layersArray.length === 1;
        if (onlyHasSingleLayer) {
            // Clone the capabilitiesLayer as we'll modify it in a second
            const out = Object.assign({}, this.capabilitiesLayers.get(this.catalogItem.layersArray[0]));
            if (out !== undefined) {
                // The Dimension object is really weird and has a bunch of stray text in there
                if ("Dimension" in out) {
                    const goodDimension = {};
                    Object.keys(out.Dimension).forEach((k) => {
                        if (isNaN(k)) {
                            goodDimension[k] = out.Dimension[k];
                        }
                    });
                    out.Dimension = goodDimension;
                }
                // remove a circular reference to the parent
                delete out._parent;
                try {
                    result.push(createStratumInstance(InfoSectionTraits, {
                        name: i18next.t("models.webMapServiceCatalogItem.dataDescription"),
                        contentAsObject: out,
                        // Hide big ugly table by default
                        show: false
                    }));
                }
                catch (e) {
                    console.log(`FAILED to create InfoSection with WMS layer Capabilities`);
                    console.log(e);
                }
            }
        }
        for (const layer of this.capabilitiesLayers.values()) {
            if (!layer ||
                !layer.Abstract ||
                containsAny(layer.Abstract, WebMapServiceCatalogItem.abstractsToIgnore)) {
                continue;
            }
            const suffix = this.capabilitiesLayers.size === 1 ? "" : ` - ${layer.Title}`;
            const name = `Web Map Service Layer Description${suffix}`;
            result.push(createStratumInstance(InfoSectionTraits, {
                name,
                content: layer.Abstract
            }));
            firstDataDescription = firstDataDescription || layer.Abstract;
        }
        // Show the service abstract if there is one and if it isn't the Geoserver default "A compliant implementation..."
        const service = this.capabilities && this.capabilities.Service;
        if (service) {
            if (service.ContactInformation !== undefined) {
                result.push(createStratumInstance(InfoSectionTraits, {
                    name: i18next.t("models.webMapServiceCatalogItem.serviceContact"),
                    content: getServiceContactInformation(service.ContactInformation)
                }));
            }
            result.push(createStratumInstance(InfoSectionTraits, {
                name: i18next.t("models.webMapServiceCatalogItem.getCapabilitiesUrl"),
                content: this.catalogItem.getCapabilitiesUrl
            }));
            if (service &&
                service.Abstract &&
                !containsAny(service.Abstract, WebMapServiceCatalogItem.abstractsToIgnore) &&
                service.Abstract !== firstDataDescription) {
                result.push(createStratumInstance(InfoSectionTraits, {
                    name: i18next.t("models.webMapServiceCatalogItem.serviceDescription"),
                    content: service.Abstract
                }));
            }
            // Show the Access Constraints if it isn't "none" (because that's the default, and usually a lie).
            if (service.AccessConstraints &&
                !/^none$/i.test(service.AccessConstraints)) {
                result.push(createStratumInstance(InfoSectionTraits, {
                    name: i18next.t("models.webMapServiceCatalogItem.accessConstraints"),
                    content: service.AccessConstraints
                }));
            }
        }
        return result;
    }
    get infoSectionOrder() {
        let layerDescriptions = [`Web Map Service Layer Description`];
        // If more than one layer, push layer description titles for each applicable layer
        if (this.capabilitiesLayers.size > 1) {
            layerDescriptions = [];
            this.capabilitiesLayers.forEach(layer => {
                if (layer &&
                    layer.Abstract &&
                    !containsAny(layer.Abstract, WebMapServiceCatalogItem.abstractsToIgnore)) {
                    layerDescriptions.push(`Web Map Service Layer Description - ${layer.Title}`);
                }
            });
        }
        return [
            i18next.t("preview.disclaimer"),
            i18next.t("description.name"),
            ...layerDescriptions,
            i18next.t("preview.datasetDescription"),
            i18next.t("preview.serviceDescription"),
            i18next.t("models.webMapServiceCatalogItem.serviceDescription"),
            i18next.t("preview.resourceDescription"),
            i18next.t("preview.licence"),
            i18next.t("preview.accessConstraints"),
            i18next.t("models.webMapServiceCatalogItem.accessConstraints"),
            i18next.t("preview.author"),
            i18next.t("preview.contact"),
            i18next.t("models.webMapServiceCatalogItem.serviceContact"),
            i18next.t("preview.created"),
            i18next.t("preview.modified"),
            i18next.t("preview.updateFrequency"),
            i18next.t("models.webMapServiceCatalogItem.getCapabilitiesUrl")
        ];
    }
    get shortReport() {
        const catalogItem = this.catalogItem;
        if (catalogItem.isShowingDiff) {
            const format = "yyyy/mm/dd";
            const d1 = dateFormat(catalogItem.firstDiffDate, format);
            const d2 = dateFormat(catalogItem.secondDiffDate, format);
            return `Showing difference image computed for ${catalogItem.diffStyleId} style on dates ${d1} and ${d2}`;
        }
    }
    get rectangle() {
        const layers = [...this.capabilitiesLayers.values()]
            .filter(layer => layer !== undefined)
            .map(l => l);
        // Needs to take union of all layer rectangles
        return layers.length > 0 ? getRectangleFromLayer(layers[0]) : undefined;
        // if (layers.length === 1) {
        //     return getRectangleFromLayer(layers[0]);
        // }
        // Otherwise get the union of rectangles from all layers
        // return undefined;
    }
    get isGeoServer() {
        var _a, _b, _c, _d;
        const keyword = (_c = (_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.Service) === null || _b === void 0 ? void 0 : _b.KeywordList) === null || _c === void 0 ? void 0 : _c.Keyword;
        return ((isReadOnlyArray(keyword) && keyword.indexOf("GEOSERVER") >= 0) ||
            keyword === "GEOSERVER" || ((_d = this.catalogItem.url) === null || _d === void 0 ? void 0 : _d.toLowerCase().includes("geoserver")));
    }
    // TODO - There is possibly a better way to do this
    get isThredds() {
        if (this.catalogItem.url &&
            (this.catalogItem.url.indexOf("thredds") > -1 ||
                this.catalogItem.url.indexOf("tds") > -1)) {
            return true;
        }
        return false;
    }
    // TODO - Geoserver also support NCWMS via a plugin, just need to work out how to detect that
    get isNcWMS() {
        if (this.catalogItem.isThredds)
            return true;
        return false;
    }
    get isEsri() {
        if (this.catalogItem.url !== undefined)
            return this.catalogItem.url.indexOf("MapServer/WMSServer") > -1;
        return false;
    }
    get supportsGetLegendGraphic() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return (isDefined((_b = (_a = this.capabilities) === null || _a === void 0 ? void 0 : _a.json) === null || _b === void 0 ? void 0 : _b["xmlns:sld"]) ||
            isDefined((_f = (_e = (_d = (_c = this.capabilities) === null || _c === void 0 ? void 0 : _c.json) === null || _d === void 0 ? void 0 : _d.Capability) === null || _e === void 0 ? void 0 : _e.Request) === null || _f === void 0 ? void 0 : _f.GetLegendGraphic) ||
            ((_g = this.catalogItem.isGeoServer) !== null && _g !== void 0 ? _g : false) ||
            ((_h = this.catalogItem.isNcWMS) !== null && _h !== void 0 ? _h : false));
    }
    get supportsColorScaleRange() {
        return this.catalogItem.isNcWMS;
    }
    get discreteTimes() {
        const result = [];
        for (let layer of this.capabilitiesLayers.values()) {
            if (!layer) {
                continue;
            }
            const dimensions = this.capabilities.getInheritedValues(layer, "Dimension");
            const timeDimension = dimensions.find(dimension => dimension.name.toLowerCase() === "time");
            if (!timeDimension) {
                continue;
            }
            let extent = timeDimension;
            // WMS 1.1.1 puts dimension values in an Extent element instead of directly in the Dimension element.
            const extentElements = this.capabilities.getInheritedValues(layer, "Extent");
            const extentElement = extentElements.find(extent => extent.name.toLowerCase() === "time");
            if (extentElement) {
                extent = extentElement;
            }
            if (!extent || !extent.split) {
                continue;
            }
            const values = extent.split(",");
            for (let i = 0; i < values.length; ++i) {
                const value = values[i];
                const isoSegments = value.split("/");
                if (isoSegments.length === 1) {
                    result.push({
                        time: values[i],
                        tag: undefined
                    });
                }
                else {
                    createDiscreteTimesFromIsoSegments(result, isoSegments[0], isoSegments[1], isoSegments[2], this.catalogItem.maxRefreshIntervals);
                }
            }
        }
        return result;
    }
    get currentTime() {
        // Get default times for all layers
        const defaultTimes = filterOutUndefined(Array.from(this.capabilitiesLayers).map(([layerName, layer]) => {
            if (!layer)
                return;
            const dimensions = this.capabilities.getInheritedValues(layer, "Dimension");
            const timeDimension = dimensions.find(dimension => dimension.name.toLowerCase() === "time");
            return timeDimension === null || timeDimension === void 0 ? void 0 : timeDimension.default;
        }));
        // Return first default time
        return defaultTimes[0];
    }
}
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "metadataUrls", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "layers", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "legends", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "capabilitiesLayers", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "crs", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "availableDimensions", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "availableStyles", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "info", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "infoSectionOrder", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "shortReport", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "rectangle", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "isGeoServer", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "isThredds", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "isNcWMS", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "isEsri", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "supportsGetLegendGraphic", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "supportsColorScaleRange", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "discreteTimes", null);
__decorate([
    computed
], GetCapabilitiesStratum.prototype, "currentTime", null);
class DiffStratum extends LoadableStratum(WebMapServiceCatalogItemTraits) {
    constructor(catalogItem) {
        super();
        this.catalogItem = catalogItem;
    }
    duplicateLoadableStratum(model) {
        return new DiffStratum(model);
    }
    get legends() {
        if (this.catalogItem.isShowingDiff && this.diffLegendUrl) {
            const urlMimeType = new URL(this.diffLegendUrl).searchParams.get("format") || undefined;
            return [
                createStratumInstance(LegendTraits, {
                    url: this.diffLegendUrl,
                    urlMimeType
                })
            ];
        }
        return undefined;
    }
    get diffLegendUrl() {
        const diffStyleId = this.catalogItem.diffStyleId;
        const firstDate = this.catalogItem.firstDiffDate;
        const secondDate = this.catalogItem.secondDiffDate;
        if (diffStyleId && firstDate && secondDate) {
            return this.catalogItem.getLegendUrlForStyle(diffStyleId, JulianDate.fromIso8601(firstDate), JulianDate.fromIso8601(secondDate));
        }
        return undefined;
    }
    get disableDateTimeSelector() {
        return this.catalogItem.isShowingDiff;
    }
}
__decorate([
    computed
], DiffStratum.prototype, "legends", null);
__decorate([
    computed
], DiffStratum.prototype, "diffLegendUrl", null);
__decorate([
    computed
], DiffStratum.prototype, "disableDateTimeSelector", null);
class WebMapServiceCatalogItem extends TileErrorHandlerMixin(ExportableMixin(DiffableMixin(TimeFilterMixin(ChartableMixin(MinMaxLevelMixin(GetCapabilitiesMixin(UrlMixin(CatalogMemberMixin(CreateModel(WebMapServiceCatalogItemTraits)))))))))) {
    constructor() {
        super(...arguments);
        // hide elements in the info section which might show information about the datasource
        this._sourceInfoItemNames = [
            i18next.t("models.webMapServiceCatalogItem.getCapabilitiesUrl")
        ];
        this._webMapServiceCatalogGroup = undefined;
        this._createImageryProvider = createTransformerAllowUndefined((time) => {
            var _a;
            // Don't show anything on the map until GetCapabilities finishes loading.
            if (this.isLoadingMetadata) {
                return undefined;
            }
            if (this.url === undefined) {
                return undefined;
            }
            console.log(`Creating new ImageryProvider for time ${time}`);
            // Set dimensionParameters
            const dimensionParameters = formatDimensionsForOws(this.dimensions);
            if (time !== undefined) {
                dimensionParameters.time = time;
            }
            const diffModeParameters = this.isShowingDiff
                ? this.diffModeParameters
                : {};
            const parameters = {
                ...WebMapServiceCatalogItem.defaultParameters,
                ...this.parameters,
                ...dimensionParameters
            };
            if (this.crs) {
                parameters.crs = this.crs;
            }
            if (this.supportsColorScaleRange) {
                parameters.COLORSCALERANGE = this.colorScaleRange;
            }
            if (isDefined(this.styles)) {
                parameters.styles = this.styles;
            }
            Object.assign(parameters, diffModeParameters);
            const maximumLevel = this.getMaximumLevel(true);
            const queryParametersToRemove = [
                "request",
                "service",
                "x",
                "y",
                "width",
                "height",
                "bbox",
                "layers"
            ];
            const baseUrl = queryParametersToRemove.reduce((url, parameter) => url.removeQuery(parameter), new URI(this.url));
            const gcStratum = this.strata.get(GetCapabilitiesMixin.getCapabilitiesStratumName);
            let lyrs = [];
            if (this.layers && gcStratum !== undefined) {
                this.layersArray.forEach(function (lyr) {
                    const gcLayer = gcStratum.capabilities.findLayer(lyr);
                    if (gcLayer !== undefined && gcLayer.Name)
                        lyrs.push(gcLayer.Name);
                });
            }
            const imageryOptions = {
                url: proxyCatalogItemUrl(this, baseUrl.toString()),
                layers: lyrs.length > 0 ? lyrs.join(",") : "",
                parameters,
                getFeatureInfoParameters: {
                    ...this.parameters,
                    ...dimensionParameters,
                    feature_count: 1 +
                        ((_a = this.maximumShownFeatureInfos) !== null && _a !== void 0 ? _a : this.terria.configParameters.defaultMaximumShownFeatureInfos),
                    styles: this.styles === undefined ? "" : this.styles
                },
                tileWidth: this.tileWidth,
                tileHeight: this.tileHeight,
                tilingScheme: this.tilingScheme,
                maximumLevel,
                credit: this.attribution
            };
            if (imageryOptions.maximumLevel !== undefined &&
                this.hideLayerAfterMinScaleDenominator) {
                // Make Cesium request one extra level so we can tell the user what's happening and return a blank image.
                ++imageryOptions.maximumLevel;
            }
            const imageryProvider = new WebMapServiceImageryProvider(imageryOptions);
            return this.updateRequestImage(imageryProvider);
        });
    }
    get type() {
        return WebMapServiceCatalogItem.type;
    }
    get shortReport() {
        if (this.tilingScheme instanceof GeographicTilingScheme &&
            this.terria.currentViewer.type === "Leaflet") {
            return i18next.t("map.cesium.notWebMercatorTilingScheme", this);
        }
        return super.shortReport;
    }
    get colorScaleRange() {
        if (this.supportsColorScaleRange) {
            return `${this.colorScaleMinimum},${this.colorScaleMaximum}`;
        }
        return undefined;
    }
    async createGetCapabilitiesStratumFromParent(capabilities) {
        const stratum = await GetCapabilitiesStratum.load(this, capabilities);
        runInAction(() => {
            this.strata.set(GetCapabilitiesMixin.getCapabilitiesStratumName, stratum);
        });
    }
    async forceLoadMetadata() {
        if (this.strata.get(GetCapabilitiesMixin.getCapabilitiesStratumName) !==
            undefined)
            return;
        const stratum = await GetCapabilitiesStratum.load(this);
        runInAction(() => {
            this.strata.set(GetCapabilitiesMixin.getCapabilitiesStratumName, stratum);
            const diffStratum = new DiffStratum(this);
            this.strata.set(DiffableMixin.diffStratumName, diffStratum);
        });
    }
    get cacheDuration() {
        if (isDefined(super.cacheDuration)) {
            return super.cacheDuration;
        }
        return "0d";
    }
    get _canExportData() {
        return isDefined(this.linkedWcsCoverage) && isDefined(this.linkedWcsUrl);
    }
    _exportData() {
        return callWebCoverageService(this);
    }
    get layersArray() {
        if (Array.isArray(this.layers)) {
            return this.layers;
        }
        else if (this.layers) {
            return this.layers.split(",");
        }
        else {
            return [];
        }
    }
    get stylesArray() {
        if (Array.isArray(this.styles)) {
            return this.styles;
        }
        else if (this.styles) {
            return this.styles.split(",");
        }
        else {
            return [];
        }
    }
    get discreteTimes() {
        const getCapabilitiesStratum = this.strata.get(GetCapabilitiesMixin.getCapabilitiesStratumName);
        return getCapabilitiesStratum === null || getCapabilitiesStratum === void 0 ? void 0 : getCapabilitiesStratum.discreteTimes;
    }
    get defaultGetCapabilitiesUrl() {
        if (this.uri) {
            return this.uri
                .clone()
                .setSearch({
                service: "WMS",
                version: "1.3.0",
                request: "GetCapabilities"
            })
                .toString();
        }
        else {
            return undefined;
        }
    }
    get canDiffImages() {
        const hasValidDiffStyles = this.availableDiffStyles.some(diffStyle => { var _a, _b, _c; return (_c = (_b = (_a = this.styleSelectableDimensions) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.find(style => style.id === diffStyle); });
        return hasValidDiffStyles === true;
    }
    showDiffImage(firstDate, secondDate, diffStyleId) {
        if (this.canDiffImages === false) {
            return;
        }
        // A helper to get the diff tag given a date string
        const firstDateStr = this.getTagForTime(firstDate);
        const secondDateStr = this.getTagForTime(secondDate);
        this.setTrait(CommonStrata.user, "firstDiffDate", firstDateStr);
        this.setTrait(CommonStrata.user, "secondDiffDate", secondDateStr);
        this.setTrait(CommonStrata.user, "diffStyleId", diffStyleId);
        this.setTrait(CommonStrata.user, "isShowingDiff", true);
    }
    clearDiffImage() {
        this.setTrait(CommonStrata.user, "firstDiffDate", undefined);
        this.setTrait(CommonStrata.user, "secondDiffDate", undefined);
        this.setTrait(CommonStrata.user, "diffStyleId", undefined);
        this.setTrait(CommonStrata.user, "isShowingDiff", false);
    }
    getLegendUrlForStyle(styleId, firstDate, secondDate) {
        var _a;
        const firstTag = firstDate && this.getTagForTime(firstDate);
        const secondTag = secondDate && this.getTagForTime(secondDate);
        const time = filterOutUndefined([firstTag, secondTag]).join(",");
        const layerName = (_a = this.availableStyles.find(style => style.styles.some(s => s.name === styleId))) === null || _a === void 0 ? void 0 : _a.layerName;
        const uri = URI(`${this.url}?service=WMS&version=1.1.0&request=GetLegendGraphic&format=image/png&transparent=True`)
            .addQuery("layer", encodeURIComponent(layerName || ""))
            .addQuery("styles", encodeURIComponent(styleId));
        if (time) {
            uri.addQuery("time", time);
        }
        return uri.toString();
    }
    forceLoadMapItems() {
        return Promise.resolve();
    }
    get mapItems() {
        if (this.isShowingDiff === true) {
            return this._diffImageryParts ? [this._diffImageryParts] : [];
        }
        const result = [];
        const current = this._currentImageryParts;
        if (current) {
            result.push(current);
        }
        const next = this._nextImageryParts;
        if (next) {
            result.push(next);
        }
        return result;
    }
    get tilingScheme() {
        if (this.crs) {
            if (SUPPORTED_CRS_3857.includes(this.crs))
                return new WebMercatorTilingScheme();
            if (SUPPORTED_CRS_4326.includes(this.crs))
                return new GeographicTilingScheme();
        }
        return new WebMercatorTilingScheme();
    }
    get _currentImageryParts() {
        const imageryProvider = this._createImageryProvider(this.currentDiscreteTimeTag);
        if (imageryProvider === undefined) {
            return undefined;
        }
        imageryProvider.enablePickFeatures = true;
        return {
            imageryProvider,
            alpha: this.opacity,
            show: this.show,
            clippingRectangle: this.clipToRectangle ? this.cesiumRectangle : undefined
        };
    }
    get _nextImageryParts() {
        if (this.nextDiscreteTimeTag) {
            const imageryProvider = this._createImageryProvider(this.nextDiscreteTimeTag);
            if (imageryProvider === undefined) {
                return undefined;
            }
            imageryProvider.enablePickFeatures = false;
            return {
                imageryProvider,
                alpha: 0.0,
                show: true,
                clippingRectangle: this.clipToRectangle
                    ? this.cesiumRectangle
                    : undefined
            };
        }
        else {
            return undefined;
        }
    }
    get _diffImageryParts() {
        const diffStyleId = this.diffStyleId;
        if (this.firstDiffDate === undefined ||
            this.secondDiffDate === undefined ||
            diffStyleId === undefined) {
            return;
        }
        const time = `${this.firstDiffDate},${this.secondDiffDate}`;
        const imageryProvider = this._createImageryProvider(time);
        if (imageryProvider) {
            return {
                imageryProvider,
                alpha: this.opacity,
                show: this.show,
                clippingRectangle: this.clipToRectangle
                    ? this.cesiumRectangle
                    : undefined
            };
        }
        return undefined;
    }
    get diffModeParameters() {
        return { styles: this.diffStyleId };
    }
    getTagForTime(date) {
        var _a;
        const index = this.getDiscreteTimeIndex(date);
        return index !== undefined
            ? (_a = this.discreteTimesAsSortedJulianDates) === null || _a === void 0 ? void 0 : _a[index].tag : undefined;
    }
    get styleSelectableDimensions() {
        return this.availableStyles.map((layer, layerIndex) => {
            var _a, _b, _c;
            let name = "Styles";
            // If multiple layers -> prepend layer name to name
            if (this.availableStyles.length > 1) {
                // Attempt to get layer title from GetCapabilitiesStratum
                const layerTitle = layer.layerName && ((_a = this.strata.get(GetCapabilitiesMixin.getCapabilitiesStratumName).capabilitiesLayers.get(layer.layerName)) === null || _a === void 0 ? void 0 : _a.Title);
                name = `${layerTitle ||
                    layer.layerName ||
                    `Layer ${layerIndex + 1}`} styles`;
            }
            const options = filterOutUndefined(layer.styles.map(function (s) {
                if (isDefined(s.name)) {
                    return {
                        name: s.title || s.name || "",
                        id: s.name
                    };
                }
            }));
            // Try to set selectedId to value stored in `styles` trait for this `layerIndex`
            // The `styles` parameter is CSV, a style for each layer
            let selectedId = (_c = (_b = this.styles) === null || _b === void 0 ? void 0 : _b.split(",")) === null || _c === void 0 ? void 0 : _c[layerIndex];
            // There is no way of finding out default style if no style has been selected :(
            // If !supportsGetLegendGraphic - we have to just use the first available style
            if (!isDefined(selectedId) &&
                options.length > 0 &&
                !this.supportsGetLegendGraphic) {
                selectedId = options[0].id;
            }
            return {
                name,
                id: `${this.uniqueId}-${layer.layerName}-styles`,
                options,
                selectedId,
                setDimensionValue: (stratumId, newStyle) => {
                    runInAction(() => {
                        const styles = this.styleSelectableDimensions.map(style => style.selectedId || "");
                        styles[layerIndex] = newStyle;
                        this.setTrait(stratumId, "styles", styles.join(","));
                    });
                },
                // Only allow undefined if more then one style (if there is only one style then it is the default style!) - and WMS server supports GetLegendGraphic (otherwise we can't request default styles!)
                allowUndefined: this.supportsGetLegendGraphic && options.length > 1,
                undefinedLabel: i18next.t("models.webMapServiceCatalogItem.defaultStyleLabel"),
                disable: this.isShowingDiff
            };
        });
    }
    get wmsDimensionSelectableDimensions() {
        const dimensions = [];
        // For each layer -> For each dimension
        this.availableDimensions.forEach(layer => {
            layer.dimensions.forEach(dim => {
                var _a, _b;
                // Only add dimensions if hasn't already been added (multiple layers may have the same dimension)
                if (!isDefined(dim.name) ||
                    dim.values.length < 2 ||
                    dimensions.findIndex(findDim => findDim.name === dim.name) !== -1) {
                    return;
                }
                dimensions.push({
                    name: dim.name,
                    id: `${this.uniqueId}-${dim.name}`,
                    options: dim.values.map(value => {
                        let name = value;
                        // Add units and unitSybol if defined
                        if (typeof dim.units === "string" && dim.units !== "") {
                            if (typeof dim.unitSymbol === "string" && dim.unitSymbol !== "") {
                                name = `${value} (${dim.units} ${dim.unitSymbol})`;
                            }
                            else {
                                name = `${value} (${dim.units})`;
                            }
                        }
                        return {
                            name,
                            id: value
                        };
                    }),
                    // Set selectedId to value stored in `dimensions` trait, the default value, or the first available value
                    selectedId: ((_b = (_a = this.dimensions) === null || _a === void 0 ? void 0 : _a[dim.name]) === null || _b === void 0 ? void 0 : _b.toString()) ||
                        dim.default ||
                        dim.values[0],
                    setDimensionValue: (stratumId, newDimension) => {
                        let newDimensions = {};
                        newDimensions[dim.name] = newDimension;
                        if (isDefined(this.dimensions)) {
                            newDimensions = combine(newDimensions, this.dimensions);
                        }
                        runInAction(() => {
                            this.setTrait(stratumId, "dimensions", newDimensions);
                        });
                    }
                });
            });
        });
        return dimensions;
    }
    get selectableDimensions() {
        if (this.disableDimensionSelectors) {
            return super.selectableDimensions;
        }
        return filterOutUndefined([
            ...super.selectableDimensions,
            ...this.wmsDimensionSelectableDimensions,
            ...this.styleSelectableDimensions
        ]);
    }
}
/**
 * The collection of strings that indicate an Abstract property should be ignored.  If these strings occur anywhere
 * in the Abstract, the Abstract will not be used.  This makes it easy to filter out placeholder data like
 * Geoserver's "A compliant implementation of WMS..." stock abstract.
 */
WebMapServiceCatalogItem.abstractsToIgnore = ["A compliant implementation of WMS"];
WebMapServiceCatalogItem.defaultParameters = {
    transparent: true,
    format: "image/png",
    exceptions: "application/vnd.ogc.se_xml",
    styles: "",
    tiled: true
};
WebMapServiceCatalogItem.type = "wms";
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "shortReport", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "colorScaleRange", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "cacheDuration", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "_canExportData", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "layersArray", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "stylesArray", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "discreteTimes", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "canDiffImages", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "mapItems", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "tilingScheme", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "_currentImageryParts", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "_nextImageryParts", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "_diffImageryParts", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "diffModeParameters", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "styleSelectableDimensions", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "wmsDimensionSelectableDimensions", null);
__decorate([
    computed
], WebMapServiceCatalogItem.prototype, "selectableDimensions", null);
/**
 * Add `_dim` prefix to dimensions for OWS (WMS, WCS...) excluding time, styles and elevation
 */
export function formatDimensionsForOws(dimensions) {
    if (!isDefined(dimensions)) {
        return {};
    }
    return Object.entries(dimensions).reduce((formattedDimensions, [key, value]) => {
        formattedDimensions[["time", "styles", "elevation"].includes(key === null || key === void 0 ? void 0 : key.toLowerCase())
            ? key
            : `dim_${key}`] = value;
        return formattedDimensions;
    }, {});
}
function getServiceContactInformation(contactInfo) {
    const primary = contactInfo.ContactPersonPrimary;
    let text = "";
    if (isDefined(primary)) {
        if (isDefined(primary.ContactOrganization) &&
            primary.ContactOrganization.length > 0 &&
            // Geoserver default
            primary.ContactOrganization !== "The Ancient Geographers") {
            text += primary.ContactOrganization + "<br/>";
        }
    }
    if (isDefined(contactInfo.ContactElectronicMailAddress) &&
        contactInfo.ContactElectronicMailAddress.length > 0 &&
        // Geoserver default
        contactInfo.ContactElectronicMailAddress !== "claudius.ptolomaeus@gmail.com") {
        text += `[${contactInfo.ContactElectronicMailAddress}](mailto:${contactInfo.ContactElectronicMailAddress})`;
    }
    return text;
}
export default WebMapServiceCatalogItem;
//# sourceMappingURL=WebMapServiceCatalogItem.js.map