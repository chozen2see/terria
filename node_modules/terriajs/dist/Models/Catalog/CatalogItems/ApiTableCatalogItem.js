var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import dateFormat from "dateformat";
import { computed, observable, runInAction } from "mobx";
import URI from "urijs";
import isDefined from "../../../Core/isDefined";
import loadJson from "../../../Core/loadJson";
import AutoRefreshingMixin from "../../../ModelMixins/AutoRefreshingMixin";
import CatalogMemberMixin from "../../../ModelMixins/CatalogMemberMixin";
import TableMixin from "../../../ModelMixins/TableMixin";
import TableAutomaticStylesStratum from "../../../Table/TableAutomaticStylesStratum";
import ApiTableCatalogItemTraits from "../../../Traits/TraitsClasses/ApiTableCatalogItemTraits";
import TableStyleTraits from "../../../Traits/TraitsClasses/TableStyleTraits";
import TableTimeStyleTraits from "../../../Traits/TraitsClasses/TableTimeStyleTraits";
import CreateModel from "../../Definition/CreateModel";
import createStratumInstance from "../../Definition/createStratumInstance";
import LoadableStratum from "../../Definition/LoadableStratum";
import proxyCatalogItemUrl from "../proxyCatalogItemUrl";
import saveModelToJson from "../../Definition/saveModelToJson";
import StratumOrder from "../../Definition/StratumOrder";
export class ApiTableStratum extends LoadableStratum(ApiTableCatalogItemTraits) {
    constructor(catalogItem) {
        super();
        this.catalogItem = catalogItem;
    }
    duplicateLoadableStratum(model) {
        return new ApiTableStratum(model);
    }
    // Set time id columns to `idKey`
    get defaultStyle() {
        return createStratumInstance(TableStyleTraits, {
            time: createStratumInstance(TableTimeStyleTraits, {
                idColumns: this.catalogItem.idKey ? [this.catalogItem.idKey] : undefined
            })
        });
    }
}
ApiTableStratum.stratumName = "apiTable";
__decorate([
    computed
], ApiTableStratum.prototype, "defaultStyle", null);
StratumOrder.addLoadStratum(ApiTableStratum.stratumName);
/**
 * THE API AND TRAITS OF THIS EXPERIMENTAL CATALOG ITEM SHOULD BE CONSIDERED IN
 * ALPHA. EXPECT BREAKING CHANGES.
 *
 * This is a generic, one-size-fits-most catalog item for deriving tables from
 * external APIs. Currently only supports JSON APIs, and doesn't support region
 * mapping. Also currently only supports a single API to get values from, and a
 * single API to get positions from.
 */
export class ApiTableCatalogItem extends AutoRefreshingMixin(TableMixin(CatalogMemberMixin(CreateModel(ApiTableCatalogItemTraits)))) {
    constructor(id, terria) {
        super(id, terria);
        this.apiResponses = [];
        this.hasData = false;
        this.strata.set(TableAutomaticStylesStratum.stratumName, new TableAutomaticStylesStratum(this));
        this.strata.set(ApiTableStratum.stratumName, new ApiTableStratum(this));
    }
    get type() {
        return ApiTableCatalogItem.type;
    }
    get apiDataIsLoaded() {
        return this.apiResponses.length > 0;
    }
    loadDataFromApis() {
        const apisWithUrl = this.apis.filter(api => api.url);
        const apiUrls = apisWithUrl.map(api => proxyCatalogItemUrl(this, api.url));
        return Promise.all(apisWithUrl.map(async (api, idx) => {
            const data = await loadJson(apiUrls[idx], undefined, api.requestData
                ? saveModelToJson(api.requestData)
                : undefined, api.postRequestDataAsFormData);
            return Promise.resolve({
                data,
                api
            });
        })).then((values) => {
            runInAction(() => {
                // Make map of ids to values that are constant for that id
                const perIdData = new Map(values
                    .filter(val => val.api.kind === "PER_ID") // per id only
                    .map(val => val.data) // throw away api, keep data
                    .reduce((curr, prev) => curr.concat(prev), []) // flatten
                    // make id/data pair for perIdData map
                    .map(data => [data[this.idKey], data]));
                // Merge PER_ID data with *all* PER_ROW data (this may result in the same PER_ID data row being added to multiple PER_ROW data row)
                const perRowData = values
                    .filter(val => val.api.kind === "PER_ROW")
                    .map(val => val.data)
                    .reduce((curr, prev) => curr.concat(prev), [])
                    .map(row => Object.assign(row, isDefined(row[this.idKey]) ? perIdData.get(row[this.idKey]) : {}));
                this.apiResponses = perRowData;
            });
        });
    }
    makeTableColumns(addHeaders) {
        return this.columns.map(col => { var _a; return (addHeaders ? [(_a = col.name) !== null && _a !== void 0 ? _a : ""] : []); });
    }
    apiResponseToTable() {
        const columnMajorTable = this.makeTableColumns(!this.hasData);
        if (!this.apiDataIsLoaded) {
            // No data yet, just return the headers
            return columnMajorTable;
        }
        // Fill in column values from the API response
        this.apiResponses.forEach(response => {
            this.columns.forEach((col, mappingIdx) => {
                var _a;
                if (!isDefined(col.name))
                    return;
                // Append the new value to the correct column
                columnMajorTable[mappingIdx].push(`${(_a = response[col.name]) !== null && _a !== void 0 ? _a : ""}`);
            });
        });
        return columnMajorTable;
    }
    async forceLoadMetadata() {
        return Promise.resolve();
    }
    async forceLoadTableData() {
        return this.loadDataFromApis()
            .then(() => {
            runInAction(() => {
                this.append(this.apiResponseToTable());
                this.hasData = true;
            });
        })
            .then(() => undefined);
    }
    refreshData() {
        this.loadDataFromApis().then(() => {
            runInAction(() => {
                this.append(this.apiResponseToTable());
            });
        });
    }
    addQueryParams(api) {
        const uri = new URI(api.url);
        const substituteDateTimesInQueryParam = (param) => {
            if (param.startsWith("DATE!")) {
                const dateFormatString = param.slice(param.indexOf("!") + 1);
                const now = new Date();
                return dateFormat(now, dateFormatString);
            }
            return param;
        };
        // Add common query parameters
        let useUpdateParams = this.hasData && this.updateQueryParameters.length > 0;
        const commonQueryParameters = useUpdateParams
            ? this.updateQueryParameters
            : this.queryParameters;
        commonQueryParameters.forEach(query => {
            uri.addQuery(query.name, substituteDateTimesInQueryParam(query.value));
        });
        // Add API-specific query parameters
        useUpdateParams = this.hasData && api.updateQueryParameters.length > 0;
        const specificQueryParameters = useUpdateParams
            ? api.updateQueryParameters
            : api.queryParameters;
        specificQueryParameters.forEach(query => {
            uri.addQuery(query.name, substituteDateTimesInQueryParam(query.value));
        });
        return uri.toString();
    }
}
ApiTableCatalogItem.type = "api-table";
__decorate([
    observable
], ApiTableCatalogItem.prototype, "apiResponses", void 0);
__decorate([
    observable
], ApiTableCatalogItem.prototype, "hasData", void 0);
__decorate([
    computed
], ApiTableCatalogItem.prototype, "apiDataIsLoaded", null);
StratumOrder.addLoadStratum(TableAutomaticStylesStratum.stratumName);
//# sourceMappingURL=ApiTableCatalogItem.js.map