var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Document } from "flexsearch";
import { action, runInAction } from "mobx";
import loadJson from "../../Core/loadJson";
import CatalogIndexReference from "../Catalog/CatalogReferences/CatalogIndexReference";
import CommonStrata from "../Definition/CommonStrata";
import updateModelFromJson from "../Definition/updateModelFromJson";
import SearchResult from "./SearchResult";
export default class CatalogIndex {
    constructor(terria, url) {
        this.terria = terria;
        this.url = url;
        this.loadPromise = this.loadCatalogIndex();
    }
    get models() {
        return this._models;
    }
    get searchIndex() {
        return this._searchIndex;
    }
    /** The catalog index is loaded automatically on startup.
     * It is loaded the first time loadInitSources is called (see Terria.forceLoadInitSources) */
    async loadCatalogIndex() {
        var _a, _b;
        // Load catalog index
        try {
            const index = (await loadJson(this.terria.corsProxy.getURLProxyIfNecessary(this.url)));
            this._models = new Map();
            /**
             * https://github.com/nextapps-de/flexsearch
             * Create search index for fields "name" and "description"
             *  - tokenize property
             *    - "full" = index every possible combination
             *    - "strict" = index whole words
             *  - resolution property = score resolution
             *
             * Note: beacuse we have set `worker: true`, we must use async calls
             */
            this._searchIndex = new Document({
                worker: true,
                document: {
                    id: "id",
                    index: [
                        {
                            field: "name",
                            tokenize: "full",
                            resolution: 9
                        },
                        {
                            field: "description",
                            tokenize: "strict",
                            resolution: 1
                        }
                    ]
                }
            });
            const indexModels = Object.entries(index);
            for (let idx = 0; idx < indexModels.length; idx++) {
                const [id, model] = indexModels[idx];
                const reference = new CatalogIndexReference(id, this.terria);
                updateModelFromJson(reference, CommonStrata.definition, model);
                // Add model to CatalogIndexReference map
                this._models.set(id, reference);
                // Add document to search index
                this._searchIndex.addAsync(id, {
                    id,
                    name: (_a = model.name) !== null && _a !== void 0 ? _a : "",
                    description: (_b = model.description) !== null && _b !== void 0 ? _b : ""
                });
            }
        }
        catch (error) {
            this.terria.raiseErrorToUser(error, "Failed to load catalog index");
        }
    }
    async search(q) {
        const results = [];
        /** Example matches object
        ```json
        [
          {
            "field": "name",
            "result": [
              "some-id-1"
            ]
          },
          {
            "field": "description",
            "result": [
              "some-id-2"
            ]
          }
        ]
        ```
    */
        if (!this.searchIndex)
            return [];
        const matches = await this.searchIndex.searchAsync(q);
        const matchedIds = new Set();
        matches.forEach((fieldResult) => {
            fieldResult.result.forEach((id) => {
                var _a;
                const indexReference = (_a = this.models) === null || _a === void 0 ? void 0 : _a.get(id);
                if (indexReference && !matchedIds.has(id)) {
                    matchedIds.add(id);
                    results.push(runInAction(() => {
                        var _a;
                        return new SearchResult({
                            name: (_a = indexReference.name) !== null && _a !== void 0 ? _a : indexReference.uniqueId,
                            catalogItem: indexReference
                        });
                    }));
                }
            });
        });
        return results;
    }
}
__decorate([
    action
], CatalogIndex.prototype, "loadCatalogIndex", null);
//# sourceMappingURL=CatalogIndex.js.map