var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import bbox from "@turf/bbox";
import i18next from "i18next";
import { action, computed, observable, runInAction, toJS } from "mobx";
import { CircleSymbolizer, GeomType, LineSymbolizer, PolygonSymbolizer } from "terriajs-protomaps";
import Cartesian3 from "terriajs-cesium/Source/Core/Cartesian3";
import clone from "terriajs-cesium/Source/Core/clone";
import Color from "terriajs-cesium/Source/Core/Color";
import defaultValue from "terriajs-cesium/Source/Core/defaultValue";
import DeveloperError from "terriajs-cesium/Source/Core/DeveloperError";
import Iso8601 from "terriajs-cesium/Source/Core/Iso8601";
import JulianDate from "terriajs-cesium/Source/Core/JulianDate";
import TimeInterval from "terriajs-cesium/Source/Core/TimeInterval";
import TimeIntervalCollection from "terriajs-cesium/Source/Core/TimeIntervalCollection";
import BillboardGraphics from "terriajs-cesium/Source/DataSources/BillboardGraphics";
import ColorMaterialProperty from "terriajs-cesium/Source/DataSources/ColorMaterialProperty";
import ConstantProperty from "terriajs-cesium/Source/DataSources/ConstantProperty";
import CzmlDataSource from "terriajs-cesium/Source/DataSources/CzmlDataSource";
import Entity from "terriajs-cesium/Source/DataSources/Entity";
import GeoJsonDataSource from "terriajs-cesium/Source/DataSources/GeoJsonDataSource";
import PointGraphics from "terriajs-cesium/Source/DataSources/PointGraphics";
import PolylineGraphics from "terriajs-cesium/Source/DataSources/PolylineGraphics";
import HeightReference from "terriajs-cesium/Source/Scene/HeightReference";
import filterOutUndefined from "../Core/filterOutUndefined";
import isDefined from "../Core/isDefined";
import { isJsonObject } from "../Core/Json";
import makeRealPromise from "../Core/makeRealPromise";
import StandardCssColors from "../Core/StandardCssColors";
import TerriaError, { networkRequestError } from "../Core/TerriaError";
import ProtomapsImageryProvider, { GEOJSON_SOURCE_LAYER_NAME } from "../Map/ProtomapsImageryProvider";
import CatalogMemberMixin from "../ModelMixins/CatalogMemberMixin";
import UrlMixin from "../ModelMixins/UrlMixin";
import proxyCatalogItemUrl from "../Models/Catalog/proxyCatalogItemUrl";
import createStratumInstance from "../Models/Definition/createStratumInstance";
import LoadableStratum from "../Models/Definition/LoadableStratum";
import StratumOrder from "../Models/Definition/StratumOrder";
import { GeoJsonTraits } from "../Traits/TraitsClasses/GeoJsonTraits";
import { RectangleTraits } from "../Traits/TraitsClasses/MappableTraits";
import DiscretelyTimeVaryingMixin from "./DiscretelyTimeVaryingMixin";
import MappableMixin from "./MappableMixin";
const formatPropertyValue = require("../Core/formatPropertyValue");
const hashFromString = require("../Core/hashFromString");
const Reproject = require("../Map/Reproject");
const simpleStyleIdentifiers = [
    "title",
    "description",
    "marker-size",
    "marker-symbol",
    "marker-color",
    "stroke",
    "stroke-opacity",
    "stroke-width",
    "fill",
    "fill-opacity"
];
class GeoJsonStratum extends LoadableStratum(GeoJsonTraits) {
    constructor(_item) {
        super();
        this._item = _item;
    }
    duplicateLoadableStratum(newModel) {
        return new GeoJsonStratum(newModel);
    }
    static load(item) {
        return new GeoJsonStratum(item);
    }
    get rectangle() {
        if (this._item._readyData) {
            const geojsonBbox = bbox(this._item._readyData);
            return createStratumInstance(RectangleTraits, {
                west: geojsonBbox[0],
                south: geojsonBbox[1],
                east: geojsonBbox[2],
                north: geojsonBbox[3]
            });
        }
    }
}
GeoJsonStratum.stratumName = "geojson";
__decorate([
    computed
], GeoJsonStratum.prototype, "rectangle", null);
StratumOrder.addLoadStratum(GeoJsonStratum.stratumName);
function GeoJsonMixin(Base) {
    class GeoJsonMixin extends DiscretelyTimeVaryingMixin(MappableMixin(UrlMixin(Base))) {
        constructor(...args) {
            super(...args);
            this.zipFileRegex = /(\.zip\b)/i;
            if (this.strata.get(GeoJsonStratum.stratumName) === undefined) {
                runInAction(() => {
                    this.strata.set(GeoJsonStratum.stratumName, GeoJsonStratum.load(this));
                });
            }
        }
        get isGeoJson() {
            return true;
        }
        setFileInput(file) {
            this._file = file;
        }
        get name() {
            if (CatalogMemberMixin.isMixedInto(this.sourceReference)) {
                return super.name || this.sourceReference.name;
            }
            return super.name;
        }
        get hasLocalData() {
            return isDefined(this._file);
        }
        get cacheDuration() {
            if (isDefined(super.cacheDuration)) {
                return super.cacheDuration;
            }
            return "1d";
        }
        /**
         * Returns the final raw data after all transformations are applied.
         */
        get readyData() {
            return this._readyData;
        }
        get mapItems() {
            if (this.isLoadingMapItems ||
                (!isDefined(this._dataSource) && !isDefined(this._imageryProvider))) {
                return [];
            }
            this._dataSource ? (this._dataSource.show = this.show) : null;
            return filterOutUndefined([
                this._dataSource,
                this._imageryProvider
                    ? {
                        imageryProvider: this._imageryProvider,
                        show: this.show,
                        alpha: 1,
                        clippingRectangle: undefined
                    }
                    : undefined
            ]);
        }
        async forceLoadMapItems() {
            // Pick which rendering mode:
            // - CZML if czmlTemplate is defined
            // - Mapbox vector tiles (see below)
            // - Cesium primitives
            // Only use MapboxVectorTiles (through geojson-vt and protomaps.js) if enabled and not using unsupported traits
            const useMvt = !this.forceCesiumPrimitives &&
                this.terria.configParameters.enableGeojsonMvt &&
                !isDefined(this.stylesWithDefaults().markerSymbol) &&
                !isDefined(this.timeProperty) &&
                !isDefined(this.heightProperty) &&
                (!isDefined(this.perPropertyStyles) ||
                    this.perPropertyStyles.length === 0);
            const czmlTemplate = this.czmlTemplate;
            try {
                const geoJson = await new Promise((resolve, reject) => {
                    this.customDataLoader(resolve, reject);
                    if (isDefined(this._file)) {
                        this.loadFromFile(this._file)
                            .then(resolve)
                            .catch(reject);
                    }
                    else if (isDefined(this.url)) {
                        // try loading from a zip file url or a regular url
                        resolve(this.loadFromUrl(this.url));
                    }
                    else {
                        throw networkRequestError({
                            sender: this,
                            title: i18next.t("models.geoJson.unableToLoadItemTitle"),
                            message: i18next.t("models.geoJson.unableToLoadItemMessage")
                        });
                    }
                });
                if (!isJsonObject(geoJson)) {
                    throw networkRequestError({
                        title: i18next.t("models.geoJson.errorLoadingTitle"),
                        message: i18next.t("models.geoJson.errorParsingMessage")
                    });
                }
                const geoJsonWgs84 = await reprojectToGeographic(geoJson, this.terria.configParameters.proj4ServiceBaseUrl);
                runInAction(() => {
                    this._readyData = geoJsonWgs84;
                });
                if (isDefined(czmlTemplate)) {
                    const dataSource = await this.loadCzmlDataSource(geoJsonWgs84);
                    runInAction(() => {
                        this._dataSource = dataSource;
                        this._imageryProvider = undefined;
                    });
                }
                else if (useMvt) {
                    runInAction(() => {
                        this._imageryProvider = this.createProtomapsImageryProvider(geoJsonWgs84);
                        this._dataSource = undefined;
                    });
                }
                else {
                    const dataSource = await this.loadGeoJsonDataSource(geoJsonWgs84);
                    runInAction(() => {
                        this._dataSource = dataSource;
                        this._imageryProvider = undefined;
                    });
                }
            }
            catch (e) {
                throw networkRequestError(TerriaError.from(e, {
                    title: i18next.t("models.geoJson.errorLoadingTitle"),
                    message: i18next.t("models.geoJson.errorParsingMessage")
                }));
            }
        }
        addPerPropertyStyleToGeoJson(json) {
            var _a;
            const geojson = json;
            if (geojson.type === "Feature") {
                const featureProperties = geojson.properties;
                if (featureProperties === null) {
                    return;
                }
                const featurePropertiesEntires = Object.entries(featureProperties);
                const matchedStyles = this.perPropertyStyles.filter(style => {
                    const stylePropertiesEntries = Object.entries(style.properties);
                    // For every key-value pair in the style, is there an identical one in the feature's properties?
                    return stylePropertiesEntries.every(([styleKey, styleValue]) => featurePropertiesEntires.find(([featKey, featValue]) => {
                        if (typeof styleValue === "string" && !style.caseSensitive) {
                            featKey === styleKey &&
                                featValue.toLowerCase() ===
                                    styleValue.toLowerCase();
                        }
                        return featKey === styleKey && featValue === styleValue;
                    }) !== undefined);
                });
                if (matchedStyles !== undefined) {
                    for (let matched of matchedStyles) {
                        for (let trait of Object.keys(matched.style.traits)) {
                            featureProperties[trait] = (_a = 
                            // @ts-ignore - TS can't tell that `trait` is of the correct index type for style
                            matched.style[trait]) !== null && _a !== void 0 ? _a : featureProperties[trait];
                        }
                    }
                }
            }
            else if (geojson.type === "FeatureCollection") {
                const featureCollection = geojson;
                featureCollection.features.forEach(feature => {
                    this.addPerPropertyStyleToGeoJson(feature);
                });
            }
        }
        createProtomapsImageryProvider(geoJson) {
            const styles = this.stylesWithDefaults();
            return new ProtomapsImageryProvider({
                terria: this.terria,
                data: geoJson,
                // Create paintRules from `stylesWithDefaults` (which applies defaults ontop of StyleTraits)
                paintRules: [
                    // Polygon fill
                    {
                        dataLayer: GEOJSON_SOURCE_LAYER_NAME,
                        symbolizer: new PolygonSymbolizer({
                            fill: styles.fill.toCssColorString()
                        }),
                        minzoom: 0,
                        maxzoom: Infinity,
                        filter: (props, feature) => {
                            return (feature === null || feature === void 0 ? void 0 : feature.geomType) === GeomType.Polygon;
                        }
                    },
                    // Polygon stroke
                    {
                        dataLayer: GEOJSON_SOURCE_LAYER_NAME,
                        symbolizer: new LineSymbolizer({
                            color: styles.polygonStroke.toCssColorString(),
                            width: styles.strokeWidth
                        }),
                        minzoom: 0,
                        maxzoom: Infinity,
                        filter: (props, feature) => {
                            return (feature === null || feature === void 0 ? void 0 : feature.geomType) === GeomType.Polygon;
                        }
                    },
                    // Line stroke
                    {
                        dataLayer: GEOJSON_SOURCE_LAYER_NAME,
                        symbolizer: new LineSymbolizer({
                            color: styles.polylineStroke.toCssColorString(),
                            width: styles.strokeWidth
                        }),
                        minzoom: 0,
                        maxzoom: Infinity,
                        filter: (props, feature) => {
                            return (feature === null || feature === void 0 ? void 0 : feature.geomType) === GeomType.Line;
                        }
                    },
                    // Point circle
                    {
                        dataLayer: GEOJSON_SOURCE_LAYER_NAME,
                        symbolizer: new CircleSymbolizer({
                            radius: styles.markerSize / 5,
                            fill: styles.markerColor.toCssColorString(),
                            width: styles.strokeWidth,
                            stroke: styles.stroke.toCssColorString()
                        }),
                        minzoom: 0,
                        maxzoom: Infinity,
                        filter: (props, feature) => {
                            return (feature === null || feature === void 0 ? void 0 : feature.geomType) === GeomType.Point;
                        }
                    }
                ],
                labelRules: []
            });
        }
        async loadCzmlDataSource(geoJson) {
            var _a, _b;
            if (geoJson.type !== "FeatureCollection" ||
                !Array.isArray(geoJson.features)) {
                throw TerriaError.from("CZML templating only supports GeoJSON FeatureCollections");
            }
            const czmlTemplate = runInAction(() => toJS(this.czmlTemplate));
            const rootCzml = [
                {
                    id: "document",
                    name: "CZML",
                    version: "1.0"
                }
            ];
            // Create a czml packet for each geoJson Point feature
            // Set czml position (cartographicDegrees) to point coordinates
            // Set czml properties to feature properties
            for (let i = 0; i < geoJson.features.length; i++) {
                const feature = geoJson.features[i];
                if (feature !== null && ((_a = feature.geometry) === null || _a === void 0 ? void 0 : _a.type) === "Point") {
                    const point = feature.geometry;
                    const czml = clone(czmlTemplate !== null && czmlTemplate !== void 0 ? czmlTemplate : {}, true);
                    const coords = point.coordinates;
                    if (coords.length === 2) {
                        coords[2] = 0;
                    }
                    czml.position = {
                        cartographicDegrees: point.coordinates
                    };
                    if (feature.properties !== null) {
                        czml.properties = Object.assign((_b = czml.properties) !== null && _b !== void 0 ? _b : {}, feature.properties);
                    }
                    rootCzml.push(czml);
                }
            }
            return CzmlDataSource.load(rootCzml);
        }
        /** Note, this is not reactive */
        stylesWithDefaults() {
            const style = this.style;
            const options = {
                describe: describeWithoutUnderscores,
                markerSize: defaultValue(parseMarkerSize(style["marker-size"]), 20),
                markerSymbol: style["marker-symbol"],
                markerColor: defaultColor(style["marker-color"], this.name || ""),
                stroke: getColor(defaultValue(style.stroke, "#000000")),
                strokeWidth: defaultValue(style["stroke-width"], 2),
                polygonStroke: getColor(defaultValue(style.stroke, "#000000")),
                polylineStroke: defaultColor(style.stroke, this.name || ""),
                markerOpacity: style["marker-opacity"],
                fill: defaultColor(style.fill, (this.name || "") + " fill"),
                clampToGround: this.clampToGround,
                markerUrl: style["marker-url"] // not in SimpleStyle spec but gives an alternate to maki marker symbols
                    ? proxyCatalogItemUrl(this, style["marker-url"])
                    : undefined,
                credit: this.attribution
            };
            if (isDefined(style["stroke-opacity"])) {
                options.stroke.alpha = style["stroke-opacity"];
            }
            if (isDefined(style["fill-opacity"])) {
                options.fill.alpha = style["fill-opacity"];
            }
            else {
                options.fill.alpha = 0.75;
            }
            return toJS(options);
        }
        loadGeoJsonDataSource(geoJson) {
            /* Style information is applied as follows, in decreasing priority:
                   - simple-style properties set directly on individual features in the GeoJSON file
                   - simple-style properties set as the 'Style' property on the catalog item
                   - our 'this.styles' set below (and point styling applied after Cesium loads the GeoJSON)
                   - if anything is underspecified there, then Cesium's defaults come in.
                   See https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0
                */
            this.addPerPropertyStyleToGeoJson(geoJson);
            const now = JulianDate.now();
            return makeRealPromise(GeoJsonDataSource.load(geoJson, this.stylesWithDefaults())).then(dataSource => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                const entities = dataSource.entities;
                for (let i = 0; i < entities.values.length; ++i) {
                    const entity = entities.values[i];
                    const properties = entity.properties;
                    // Time
                    if (isDefined(properties) &&
                        isDefined(this.timeProperty) &&
                        isDefined(this.discreteTimesAsSortedJulianDates)) {
                        const startTimeDiscreteTime = properties[this.timeProperty];
                        const startTimeIdx = (_a = this.discreteTimesAsSortedJulianDates) === null || _a === void 0 ? void 0 : _a.findIndex(t => t.tag === startTimeDiscreteTime.getValue());
                        const startTime = this.discreteTimesAsSortedJulianDates[startTimeIdx];
                        if (isDefined(startTime)) {
                            const endTimeIdx = startTimeIdx + 1;
                            const endTime = this.discreteTimesAsSortedJulianDates[endTimeIdx];
                            entity.availability = new TimeIntervalCollection([
                                new TimeInterval({
                                    start: startTime.time,
                                    stop: (_b = endTime === null || endTime === void 0 ? void 0 : endTime.time) !== null && _b !== void 0 ? _b : Iso8601.MAXIMUM_VALUE,
                                    isStopIncluded: false
                                })
                            ]);
                        }
                    }
                    const styles = this.stylesWithDefaults();
                    // Billboard
                    if (isDefined(entity.billboard) && isDefined(styles.markerUrl)) {
                        entity.billboard = new BillboardGraphics({
                            image: new ConstantProperty(styles.markerUrl),
                            width: properties && properties["marker-width"]
                                ? new ConstantProperty(properties["marker-width"])
                                : undefined,
                            height: properties && properties["marker-height"]
                                ? new ConstantProperty(properties["marker-height"])
                                : undefined,
                            rotation: properties && properties["marker-angle"]
                                ? new ConstantProperty(properties["marker-angle"])
                                : undefined,
                            heightReference: styles.clampToGround
                                ? new ConstantProperty(HeightReference.RELATIVE_TO_GROUND)
                                : undefined
                        });
                        /* If no marker symbol was provided but Cesium has generated one for a point, then turn it into
                             a filled circle instead of the default marker. */
                    }
                    else if (isDefined(entity.billboard) &&
                        (!properties || !isDefined(properties["marker-symbol"])) &&
                        !isDefined(styles.markerSymbol)) {
                        entity.point = new PointGraphics({
                            color: new ConstantProperty(getColor(defaultValue(properties && ((_c = properties["marker-color"]) === null || _c === void 0 ? void 0 : _c.getValue()), styles.markerColor))),
                            pixelSize: new ConstantProperty(defaultValue(parseMarkerSize(properties && ((_d = properties["marker-size"]) === null || _d === void 0 ? void 0 : _d.getValue())), styles.markerSize / 2)),
                            outlineWidth: new ConstantProperty(defaultValue(properties && ((_e = properties["stroke-width"]) === null || _e === void 0 ? void 0 : _e.getValue()), styles.strokeWidth)),
                            outlineColor: new ConstantProperty(getColor(defaultValue(properties && ((_f = properties.stroke) === null || _f === void 0 ? void 0 : _f.getValue()), styles.polygonStroke))),
                            heightReference: new ConstantProperty(styles.clampToGround
                                ? HeightReference.RELATIVE_TO_GROUND
                                : undefined)
                        });
                        if (properties &&
                            isDefined(properties["marker-opacity"]) &&
                            entity.point.color) {
                            // not part of SimpleStyle spec, but why not?
                            const color = entity.point.color.getValue(now);
                            color.alpha = parseFloat((_g = properties["marker-opacity"]) === null || _g === void 0 ? void 0 : _g.getValue());
                        }
                        entity.billboard = undefined;
                    }
                    if (isDefined(entity.billboard) &&
                        properties &&
                        isDefined((_h = properties["marker-opacity"]) === null || _h === void 0 ? void 0 : _h.getValue())) {
                        entity.billboard.color = new ConstantProperty(new Color(1.0, 1.0, 1.0, parseFloat((_j = properties["marker-opacity"]) === null || _j === void 0 ? void 0 : _j.getValue())));
                    }
                    if (isDefined(entity.polygon)) {
                        // Extrude polygons if heightProperty is set
                        if (this.heightProperty &&
                            properties &&
                            isDefined(properties[this.heightProperty])) {
                            entity.polygon.closeTop = new ConstantProperty(true);
                            entity.polygon.extrudedHeight = properties[this.heightProperty];
                            entity.polygon.heightReference = new ConstantProperty(HeightReference.CLAMP_TO_GROUND);
                            entity.polygon.extrudedHeightReference = new ConstantProperty(HeightReference.RELATIVE_TO_GROUND);
                        }
                        // Cesium on Windows can't render polygons with a stroke-width > 1.0.  And even on other platforms it
                        // looks bad because WebGL doesn't mitre the lines together nicely.
                        // As a workaround for the special case where the polygon is unfilled anyway, change it to a polyline.
                        else if (polygonHasWideOutline(entity.polygon, now) &&
                            !polygonIsFilled(entity.polygon)) {
                            createPolylineFromPolygon(entities, entity, now);
                            entity.polygon = undefined;
                        }
                        else if (polygonHasOutline(entity.polygon, now) &&
                            isPolygonOnTerrain(entity.polygon, now)) {
                            // Polygons don't directly support outlines when they're on terrain.
                            // So create a manual outline.
                            createPolylineFromPolygon(entities, entity, now);
                        }
                    }
                }
                return dataSource;
            });
        }
        get discreteTimes() {
            if (this.timeProperty === undefined || this.readyData === undefined) {
                return undefined;
            }
            const discreteTimesMap = new Map();
            const addFeatureToDiscreteTimes = (geojson) => {
                if (geojson.type === "Feature") {
                    let feature = geojson;
                    if (feature.properties !== null &&
                        feature.properties !== undefined &&
                        feature.properties[this.timeProperty] !== undefined) {
                        const dt = {
                            time: new Date(`${feature.properties[this.timeProperty]}`).toISOString(),
                            tag: feature.properties[this.timeProperty]
                        };
                        discreteTimesMap.set(dt.tag, dt);
                    }
                }
                else if (geojson.type === "FeatureCollection") {
                    const featureCollection = geojson;
                    featureCollection.features.forEach(feature => addFeatureToDiscreteTimes(feature));
                }
            };
            addFeatureToDiscreteTimes(this.readyData);
            return Array.from(discreteTimesMap.values());
        }
    }
    __decorate([
        observable
    ], GeoJsonMixin.prototype, "_dataSource", void 0);
    __decorate([
        observable
    ], GeoJsonMixin.prototype, "_imageryProvider", void 0);
    __decorate([
        observable.ref
    ], GeoJsonMixin.prototype, "_readyData", void 0);
    __decorate([
        computed
    ], GeoJsonMixin.prototype, "name", null);
    __decorate([
        computed
    ], GeoJsonMixin.prototype, "hasLocalData", null);
    __decorate([
        computed
    ], GeoJsonMixin.prototype, "cacheDuration", null);
    __decorate([
        computed
    ], GeoJsonMixin.prototype, "readyData", null);
    __decorate([
        computed
    ], GeoJsonMixin.prototype, "mapItems", null);
    __decorate([
        action
    ], GeoJsonMixin.prototype, "addPerPropertyStyleToGeoJson", null);
    __decorate([
        action
    ], GeoJsonMixin.prototype, "stylesWithDefaults", null);
    __decorate([
        computed
    ], GeoJsonMixin.prototype, "discreteTimes", null);
    return GeoJsonMixin;
}
(function (GeoJsonMixin) {
    function isMixedInto(model) {
        return model && model.isGeoJson;
    }
    GeoJsonMixin.isMixedInto = isMixedInto;
})(GeoJsonMixin || (GeoJsonMixin = {}));
export default GeoJsonMixin;
function createPolylineFromPolygon(entities, entity, now) {
    const polygon = entity.polygon;
    entity.polyline = new PolylineGraphics();
    entity.polyline.show = polygon.show;
    if (isPolygonOnTerrain(polygon, now)) {
        entity.polyline.clampToGround = true;
    }
    if (isDefined(polygon.outlineColor)) {
        entity.polyline.material = new ColorMaterialProperty(polygon.outlineColor);
    }
    const hierarchy = getPropertyValue(polygon.hierarchy);
    if (!hierarchy) {
        return;
    }
    const positions = closePolyline(hierarchy.positions);
    entity.polyline.positions = new ConstantProperty(positions);
    entity.polyline.width =
        polygon.outlineWidth && polygon.outlineWidth.getValue(now);
    createEntitiesFromHoles(entities, hierarchy.holes, entity);
}
async function reprojectToGeographic(geoJson, proj4ServiceBaseUrl) {
    let code;
    if (!isJsonObject(geoJson.crs)) {
        code = undefined;
    }
    else if (geoJson.crs.type === "EPSG" &&
        isJsonObject(geoJson.crs.properties) &&
        geoJson.crs.properties.code) {
        code = "EPSG:" + geoJson.crs.properties.code;
    }
    else if (isJsonObject(geoJson.crs.properties) &&
        geoJson.crs.type === "name" &&
        geoJson.crs.properties.name) {
        code = Reproject.crsStringToCode(geoJson.crs.properties.name);
    }
    geoJson.crs = {
        type: "EPSG",
        properties: {
            code: "4326"
        }
    };
    if (!Reproject.willNeedReprojecting(code)) {
        return Promise.resolve(geoJson);
    }
    const needsReprojection = await makeRealPromise(Reproject.checkProjection(proj4ServiceBaseUrl, code));
    if (needsReprojection) {
        try {
            filterValue(geoJson, "coordinates", function (obj, prop) {
                obj[prop] = filterArray(obj[prop], function (pts) {
                    if (pts.length === 0)
                        return [];
                    return reprojectPointList(pts, code);
                });
            });
            return geoJson;
        }
        catch (e) {
            throw TerriaError.from(e, "Failed to reproject geoJSON");
        }
    }
    else {
        throw new DeveloperError("The crs code for this datasource is unsupported.");
    }
}
// Reproject a point list based on the supplied crs code.
function reprojectPointList(pts, code) {
    if (!(pts[0] instanceof Array)) {
        return Reproject.reprojectPoint(pts, code, "EPSG:4326");
    }
    const pts_out = [];
    for (let i = 0; i < pts.length; i++) {
        pts_out.push(Reproject.reprojectPoint(pts[i], code, "EPSG:4326"));
    }
    return pts_out;
}
// Find a member by name in the gml.
function filterValue(obj, prop, func) {
    for (let p in obj) {
        if (obj.hasOwnProperty(p) === false) {
            continue;
        }
        else if (p === prop) {
            if (func && typeof func === "function") {
                func(obj, prop);
            }
        }
        else if (typeof obj[p] === "object") {
            filterValue(obj[p], prop, func);
        }
    }
}
// Filter a geojson coordinates array structure.
function filterArray(pts, func) {
    if (!(pts[0] instanceof Array) || !(pts[0][0] instanceof Array)) {
        pts = func(pts);
        return pts;
    }
    const result = new Array(pts.length);
    for (let i = 0; i < pts.length; i++) {
        result[i] = filterArray(pts[i], func); // at array of arrays of points
    }
    return result;
}
/**
 * Get a random color for the data based on the passed string (usually dataset name).
 */
function getRandomCssColor(cssColors, name) {
    const index = hashFromString(name || "") % cssColors.length;
    return cssColors[index];
}
// This next function modelled on Cesium.geoJsonDataSource's defaultDescribe.
function describeWithoutUnderscores(properties, nameProperty) {
    let html = "";
    for (let key in properties) {
        if (properties.hasOwnProperty(key)) {
            if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {
                continue;
            }
            let value = properties[key];
            if (typeof value === "object") {
                value = describeWithoutUnderscores(value);
            }
            else {
                value = formatPropertyValue(value);
            }
            key = key.replace(/_/g, " ");
            if (isDefined(value)) {
                html += "<tr><th>" + key + "</th><td>" + value + "</td></tr>";
            }
        }
    }
    if (html.length > 0) {
        html =
            '<table class="cesium-infoBox-defaultTable"><tbody>' +
                html +
                "</tbody></table>";
    }
    return html;
}
function polygonHasOutline(polygon, now) {
    return (isDefined(polygon.outlineWidth) && polygon.outlineWidth.getValue(now) > 0);
}
function polygonHasWideOutline(polygon, now) {
    return (isDefined(polygon.outlineWidth) && polygon.outlineWidth.getValue(now) > 1);
}
function polygonIsFilled(polygon) {
    var _a;
    let fill = true;
    if (isDefined(polygon.fill)) {
        fill = polygon.fill.getValue(new JulianDate());
    }
    if (!fill) {
        return false;
    }
    if (!isDefined(polygon.material)) {
        // The default is solid white.
        return true;
    }
    let color;
    if (polygon.material instanceof Color) {
        color = polygon.material.getValue(new JulianDate());
    }
    else {
        color = (_a = polygon.material.color) === null || _a === void 0 ? void 0 : _a.getValue(new JulianDate());
    }
    if (color && color.alpha === 0.0) {
        return false;
    }
    return true;
}
function closePolyline(positions) {
    // If the first and last positions are more than a meter apart, duplicate the first position so the polyline is closed.
    if (positions.length >= 2 &&
        !Cartesian3.equalsEpsilon(positions[0], positions[positions.length - 1], 0.0, 1.0)) {
        const copy = positions.slice();
        copy.push(positions[0]);
        return copy;
    }
    return positions;
}
function createEntitiesFromHoles(entityCollection, holes, mainEntity) {
    if (!isDefined(holes)) {
        return;
    }
    for (let i = 0; i < holes.length; ++i) {
        createEntityFromHole(entityCollection, holes[i], mainEntity);
    }
}
function createEntityFromHole(entityCollection, hole, mainEntity) {
    if (!isDefined(hole) ||
        !isDefined(hole.positions) ||
        hole.positions.length === 0) {
        return;
    }
    const entity = new Entity();
    entity.name = mainEntity.name;
    entity.availability = mainEntity.availability;
    entity.description = mainEntity.description;
    entity.properties = mainEntity.properties;
    entity.polyline = new PolylineGraphics();
    entity.polyline.show = mainEntity.polyline.show;
    entity.polyline.material = mainEntity.polyline.material;
    entity.polyline.width = mainEntity.polyline.width;
    entity.polyline.clampToGround = mainEntity.polyline.clampToGround;
    closePolyline(hole.positions);
    entity.polyline.positions = new ConstantProperty(hole.positions);
    entityCollection.add(entity);
    createEntitiesFromHoles(entityCollection, hole.holes, mainEntity);
}
function getPropertyValue(property) {
    if (property === undefined) {
        return undefined;
    }
    return property.getValue(JulianDate.now());
}
function unwrapSinglePropertyObject(obj) {
    let name;
    if (Object.keys(obj).length === 1) {
        name = Object.keys(obj)[0];
        obj = obj[name];
    }
    return { name, obj };
}
function isPolygonOnTerrain(polygon, now) {
    const polygonAny = polygon;
    const isClamped = polygonAny.heightReference &&
        polygonAny.heightReference.getValue(now) ===
            HeightReference.CLAMP_TO_GROUND;
    const hasPerPositionHeight = polygon.perPositionHeight && polygon.perPositionHeight.getValue(now);
    const hasPolygonHeight = polygon.height && polygon.height.getValue(now) !== undefined;
    return isClamped || (!hasPerPositionHeight && !hasPolygonHeight);
}
function defaultColor(colorString, name) {
    var _a;
    if (colorString === undefined) {
        const color = Color.fromCssColorString(getRandomCssColor(StandardCssColors.highContrast, name));
        color.alpha = 1;
        return color;
    }
    else {
        return (_a = Color.fromCssColorString(colorString)) !== null && _a !== void 0 ? _a : Color.GRAY;
    }
}
function getColor(color) {
    var _a;
    if (typeof color === "string" || color instanceof String) {
        return (_a = Color.fromCssColorString(color.toString())) !== null && _a !== void 0 ? _a : Color.GRAY;
    }
    else {
        return color;
    }
}
function parseMarkerSize(sizeString) {
    const sizes = {
        small: 24,
        medium: 48,
        large: 64
    };
    if (sizeString === undefined) {
        return undefined;
    }
    if (sizes[sizeString] !== undefined) {
        return sizes[sizeString];
    }
    return parseInt(sizeString, 10); // SimpleStyle doesn't allow 'marker-size: 20', but people will do it.
}
//# sourceMappingURL=GeojsonMixin.js.map